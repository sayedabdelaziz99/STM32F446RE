/*
 * RTC.c
 *
 *  Created on: Mar 22, 2024
 *      Author: Sayed
 */
#include "STMF446RE.h"
#include "RTC_driver.h"
#include "I2C_driver.h"

#define I2C_CR1_PE_Pos         0U
#define I2C_CR1_PE_Msk         (0x1UL << I2C_CR1_PE_Pos)
#define I2C_CR1_SWRST_Pos      15U
#define I2C_CR1_SWRST_Msk      (0x1UL << I2C_CR1_SWRST_Pos)
#define I2C_CR1_STOP_Pos       9U
#define I2C_CR1_STOP_Msk       (0x1UL << I2C_CR1_STOP_Pos)
#define I2C_SR1_TXE_Pos        7U
#define I2C_SR1_TXE_Msk        (0x1UL << I2C_SR1_TXE_Pos)
#define I2C_SR1_SB_Pos         0U
#define I2C_SR1_SB_Msk         (0x1UL << I2C_SR1_SB_Pos)
#define I2C_CR1_START_Pos      8U
#define I2C_CR1_START_Msk      (0x1UL << I2C_CR1_START_Pos)
#define I2C_CR1_ACK_Pos        10U
#define I2C_CR1_ACK_Msk        (0x1UL << I2C_CR1_ACK_Pos)
#define I2C_SR1_RXNE_Pos       6U
#define I2C_SR1_RXNE_Msk       (0x1UL << I2C_SR1_RXNE_Pos)

void I2C_Start(void);
void I2C_Stop(void);
void I2C_Write(uint8_t data);
uint8_t I2C_Read(uint8_t ack);
void I2C_Writeaddr(uint8_t SlaveAddress);
void RTC_timeNow(uint8_t *pRxBuffer, I2C_Handle *pI2CHandle);

void RTC_ReadTime(uint8_t *pDataBuffer){
	uint16_t SlaveAddress = 0x68U;
	//Start the reading from RTC buy making a dummy write first
    I2C_Start();

    // Send DS1307 address with write mode
    I2C_Writeaddr((SlaveAddress << 1) | 0x00); // Write mode

    // Send register address to read (0x00 for seconds)
    I2C_Write(0x00);

    // Send repeated start condition
    I2C_Start();

    // Send DS1307 address with read mode
    I2C_Writeaddr((SlaveAddress << 1) | 0x01); // Read mode
    for(uint16_t i = 0; i <6; i++){
    	if(i == 5){
    		*pDataBuffer = I2C_Read(1);
    		break;
    	}
    	*pDataBuffer = I2C_Read(1);
    	pDataBuffer++;
    }
    *pDataBuffer = I2C_Read(0);

    // Send stop condition
    I2C_Stop();
}

void RTC_timeNow(uint8_t *pRxBuffer, I2C_Handle *pI2CHandle){
	uint8_t SlaveAddress = 0x68U;
	uint8_t StartAdress = 0x00U;
	I2C_MasterSendData(pI2CHandle, &StartAdress, sizeof(StartAdress), SlaveAddress);

	I2C_MasterRecieveData(pI2CHandle, pRxBuffer, 6, SlaveAddress);

}
void I2C_Start(void) {
    I2C1->CR1 |= I2C_CR1_START_Msk; // Generate start condition
    while (!(I2C1->SR1 & I2C_SR1_SB_Msk)); // Wait until start condition is generated
}
void I2C_Stop(void) {
    I2C1->CR1 |= I2C_CR1_STOP_Msk; // Generate stop condition
}
void I2C_Write(uint8_t data) {
    I2C1->DR = data; // Write data to data register
    while (!(I2C1->SR1 & I2C_SR1_TXE_Msk)); // Wait until data is transmitted
}

void I2C_Writeaddr(uint8_t SlaveAddress) {
    I2C1->DR = SlaveAddress; // Write data to data register
    while (!(I2C1->SR1 & I2C_FLAG_ADDR)); // Wait until data is transmitted
    uint32_t DummyRead;
    DummyRead += I2C1->SR1;
    DummyRead  = I2C1 ->SR2;
}

uint8_t I2C_Read(uint8_t ack) {
    uint8_t data;

    if (ack) {
        I2C1->CR1 |= I2C_CR1_ACK_Msk; // Enable ACK
    } else {
        I2C1->CR1 &= ~I2C_CR1_ACK_Msk; // Disable ACK
    }

    while (!(I2C1->SR1 & I2C_SR1_RXNE_Msk)); // Wait until data is received
    data = I2C1->DR; // Read received data

    return data;
}

void I2C_init(void) {
    // Enable GPIOB clock
    RCC->AHB1ENR |= ( 1 << RCC_AHB1ENR_GPIOBEN);

    // Enable I2C1 clock
    RCC->APB1ENR |= (1 << RCC_APB1ENR_I2C1EN);

    // Configure I2C1 pins (PB6: SCL, PB7: SDA)
    GPIOB->MODER |= ((2 << 6 * 2) | (2 << 7 * 2)); // Alternate function mode
    GPIOB->AFR[0] |= (4 << (6 * 4)) | (4 << (7 * 4)); // AF4 (I2C1) for PB6 and PB7
    GPIOB->OTYPER |= ((1 << 6) | (1 << 7)); // Open-drain
    GPIOB->OSPEEDER |= ((3 << 6 * 4) | (3 << 6 * 2)); // High speed
    GPIOB->PUPDR |= ((1 << 6) | (1 << 7)); // Pull-up

    // Configure I2C1 peripheral
    I2C1->CR1 &= ~I2C_CR1_PE_Msk; // Disable I2C1 peripheral
    I2C1->CR1 |= I2C_CR1_SWRST_Msk; // Software reset
    I2C1->CR1 &= ~I2C_CR1_SWRST_Msk; // Release software reset
    I2C1->CR2 = 0; // Clear CR2 register
    I2C1->CCR = 80; // SCL frequency = PCLK1 / (4 * (CCR+1)) = 100kHz (assuming PCLK1 = 16MHz)
    I2C1->TRISE = 17; // Maximum rise time in standard mode
    I2C1->CR1 |= I2C_CR1_PE_Msk; // Enable I2C1 peripheral
}


