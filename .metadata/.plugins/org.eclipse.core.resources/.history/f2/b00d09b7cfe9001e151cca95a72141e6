/*
 * rtc.c
 *
 *  Created on: Mar 22, 2024
 *      Author: Sayed
 */

#include "GPIO_driver.h"
#include "I2C_driver.h"
//#include "RTC_driver.h"
#include "bsp.h"


#define I2C_CR1_PE_Pos         0U
#define I2C_CR1_PE_Msk         (0x1UL << I2C_CR1_PE_Pos)
#define I2C_CR1_SWRST_Pos      15U
#define I2C_CR1_SWRST_Msk      (0x1UL << I2C_CR1_SWRST_Pos)
#define SLAVE_ADDRESS 	0x68U
#define I2C_CR1_STOP_Pos       9U
#define I2C_CR1_STOP_Msk       (0x1UL << I2C_CR1_STOP_Pos)
#define I2C_SR1_TXE_Pos        7U
#define I2C_SR1_TXE_Msk        (0x1UL << I2C_SR1_TXE_Pos)
#define I2C_SR1_SB_Pos         0U
#define I2C_SR1_SB_Msk         (0x1UL << I2C_SR1_SB_Pos)
#define I2C_CR1_START_Pos      8U
#define I2C_CR1_START_Msk      (0x1UL << I2C_CR1_START_Pos)
#define I2C_CR1_ACK_Pos        10U
#define I2C_CR1_ACK_Msk        (0x1UL << I2C_CR1_ACK_Pos)
#define I2C_SR1_RXNE_Pos       6U
#define I2C_SR1_RXNE_Msk       (0x1UL << I2C_SR1_RXNE_Pos)

#define SlaveAddress    0x68
static void I2C_Config(I2C_Handle *pI2C_Handle);
void I2C_init(void);
void I2C_Start(void);
void I2C_Stop(void);
void I2C_WriteAddr(uint8_t address);
void I2C_Write(uint8_t data);
uint8_t I2C_Read(uint8_t ack);

uint16_t data[8];
int main(void){
	I2C_init();
	while(1){
		//Start the reading from RTC buy making a dummy write first
	    I2C_Start();

	    // Send DS1307 address with write mode
	    I2C_WriteAddr((SlaveAddress << 1) | 0x00); // Write mode

	    // Send register address to read (0x00 for seconds)
	    I2C_Write(0x00);
	    I2C_Write((0U << 7));
	    // Send repeated start condition
	    I2C_Start();

	    // Send DS1307 address with read mode
	    I2C_WriteAddr((SlaveAddress << 1) | 0x01); // Read mode
	    for(uint16_t i = 0; i < 8; i++){
	    	data[i] = I2C_Read(1);
	    }
	    // Send stop condition
	    I2C_Stop();
	}
}


void I2C_WriteAddr(uint8_t address){
    I2C1->DR = address; // Write data to data register
    while (! (I2C1->SR1 & I2C_FLAG_ADDR));
    uint32_t DummyRead;
    DummyRead += I2C1->SR1;
    DummyRead = I2C1 ->SR2;
}

static void I2C_Config(I2C_Handle *pI2C_Handle){
	/*configuring the pins first*/
	I2C1_GPIOInit(GPIOB, GPIO_PIN_NO_6, 4);  /*SCL*/
	I2C1_GPIOInit(GPIOB, GPIO_PIN_NO_7, 4);  /*SDA*/
	pI2C_Handle->pI2Cx = I2C1;
	pI2C_Handle->I2C_Config.I2C_ACKControl = I2C_ACK_ENABLE;
	pI2C_Handle->I2C_Config.I2C_AddressMode = I2C_AddressMode_7bit;
	pI2C_Handle->I2C_Config.I2C_DeviceAddress = 0x67U;
	pI2C_Handle->I2C_Config.I2C_FMDutyCycle = I2C_FM_DUTY_2;
	pI2C_Handle->I2C_Config.I2C_SCLSpeed = I2C_SCL_SM;
	I2C_CLKCNT(pI2C_Handle->pI2Cx, ENABLE);
	I2C_Init(pI2C_Handle);
}

void I2C_init(void) {
    //Enable GPIOB clock
    RCC->AHB1ENR |= (1 << RCC_AHB1ENR_GPIOBEN);

    // Enable I2C1 clock
    RCC->APB1ENR |= (1 << RCC_APB1ENR_I2C1EN);

    // Configure I2C1 pins (PB6: SCL, PB7: SDA)
    GPIOB->MODER |= (2 << 6 * 2) | (2 << 7 * 2); // Alternate function mode
    GPIOB->AFR[0] |= (4 << (6 * 4)) | (4 << (7 * 4)); // AF4 (I2C1) for PB6 and PB7
    GPIOB->OTYPER |= (1 << 6) | (1 << 7); // Open-drain
    GPIOB->OSPEEDER |= (3 << 6 * 2) | (3 << 7 * 2); // High speed
    GPIOB->PUPDR |= (1 << 6) | (1 << 7); // Pull-up

    // Configure I2C1 peripheral
    I2C1->CR1 &= ~I2C_CR1_PE_Msk; // Disable I2C1 peripheral
    I2C1->CR1 |= I2C_CR1_SWRST_Msk; // Software reset
    I2C1->CR1 &= ~I2C_CR1_SWRST_Msk; // Release software reset
    I2C1->CR2 = 0; // Clear CR2 register
    I2C1->CCR = 40; // SCL frequency = PCLK1 / (4 * (CCR+1)) = 100kHz (assuming PCLK1 = 16MHz)
    I2C1->TRISE = 17; // Maximum rise time in standard mode
    I2C1->CR1 |= I2C_CR1_PE_Msk; // Enable I2C1 peripheral
}

void I2C_Start(void) {
    I2C1->CR1 |= I2C_CR1_START_Msk; // Generate start condition
    while (!(I2C1->SR1 & I2C_SR1_SB_Msk)); // Wait until start condition is generated
}
void I2C_Stop(void) {
    I2C1->CR1 |= I2C_CR1_STOP_Msk; // Generate stop condition
}
void I2C_Write(uint8_t data) {
    I2C1->DR = data; // Write data to data register
    while (!(I2C1->SR1 & I2C_SR1_TXE_Msk)); // Wait until data is transmitted
}

uint8_t I2C_Read(uint8_t ack) {
    uint8_t data;

    if (ack) {
        I2C1->CR1 |= I2C_CR1_ACK_Msk; // Enable ACK
    } else {
        I2C1->CR1 &= ~I2C_CR1_ACK_Msk; // Disable ACK
    }

    while (!(I2C1->SR1 & I2C_SR1_RXNE_Msk)); // Wait until data is received
    data = I2C1->DR; // Read received data

    return data;
}
