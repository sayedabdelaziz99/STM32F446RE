
006BootLoader_firmware.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .BootLoader_section 00008000  08000000  08000000  00010028  2**0
                  CONTENTS, READONLY
  1 .isr_vector   000001c4  08008000  08008000  00008000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .text         00000e50  080081c4  080081c4  000081c4  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .rodata       00000000  08009014  08009014  00018028  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  4 .ARM.extab    00000000  08009014  08009014  00018028  2**0
                  CONTENTS
  5 .ARM          00000000  08009014  08009014  00018028  2**0
                  CONTENTS
  6 .preinit_array 00000000  08009014  08009014  00018028  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  7 .init_array   00000004  08009014  08009014  00009014  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  8 .fini_array   00000004  08009018  08009018  00009018  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  9 .data         00000028  20000000  0800901c  00010000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 10 .bss          000000b4  20000028  08009044  00010028  2**2
                  ALLOC
 11 ._user_heap_stack 00000444  200000dc  08009044  000100dc  2**0
                  ALLOC
 12 .ARM.attributes 0000002a  00000000  00000000  00018028  2**0
                  CONTENTS, READONLY
 13 .debug_info   00001eb6  00000000  00000000  00018052  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 14 .debug_abbrev 0000073d  00000000  00000000  00019f08  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 15 .debug_aranges 000001e8  00000000  00000000  0001a648  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 16 .debug_ranges 00000190  00000000  00000000  0001a830  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 17 .debug_macro  00002b69  00000000  00000000  0001a9c0  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 18 .debug_line   000024ca  00000000  00000000  0001d529  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 19 .debug_str    00007674  00000000  00000000  0001f9f3  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 20 .comment      00000050  00000000  00000000  00027067  2**0
                  CONTENTS, READONLY
 21 .debug_frame  0000068c  00000000  00000000  000270b8  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

080081c4 <__do_global_dtors_aux>:
 80081c4:	b510      	push	{r4, lr}
 80081c6:	4c05      	ldr	r4, [pc, #20]	; (80081dc <__do_global_dtors_aux+0x18>)
 80081c8:	7823      	ldrb	r3, [r4, #0]
 80081ca:	b933      	cbnz	r3, 80081da <__do_global_dtors_aux+0x16>
 80081cc:	4b04      	ldr	r3, [pc, #16]	; (80081e0 <__do_global_dtors_aux+0x1c>)
 80081ce:	b113      	cbz	r3, 80081d6 <__do_global_dtors_aux+0x12>
 80081d0:	4804      	ldr	r0, [pc, #16]	; (80081e4 <__do_global_dtors_aux+0x20>)
 80081d2:	f3af 8000 	nop.w
 80081d6:	2301      	movs	r3, #1
 80081d8:	7023      	strb	r3, [r4, #0]
 80081da:	bd10      	pop	{r4, pc}
 80081dc:	20000028 	.word	0x20000028
 80081e0:	00000000 	.word	0x00000000
 80081e4:	08008ffc 	.word	0x08008ffc

080081e8 <frame_dummy>:
 80081e8:	b508      	push	{r3, lr}
 80081ea:	4b03      	ldr	r3, [pc, #12]	; (80081f8 <frame_dummy+0x10>)
 80081ec:	b11b      	cbz	r3, 80081f6 <frame_dummy+0xe>
 80081ee:	4903      	ldr	r1, [pc, #12]	; (80081fc <frame_dummy+0x14>)
 80081f0:	4803      	ldr	r0, [pc, #12]	; (8008200 <frame_dummy+0x18>)
 80081f2:	f3af 8000 	nop.w
 80081f6:	bd08      	pop	{r3, pc}
 80081f8:	00000000 	.word	0x00000000
 80081fc:	2000002c 	.word	0x2000002c
 8008200:	08008ffc 	.word	0x08008ffc

08008204 <USART_GPIOInit>:
GPIO_CLKCNT(pGPIOx, ENABLE);
pGPIOx->LCKR &= ~(1 << PinNumber);
GPIO_Init(&I2CPins);
}

void USART_GPIOInit(GPIO_RegDef_t *pGPIOx, uint8_t PinNumber, uint8_t ALTFN_Mode){
 8008204:	b580      	push	{r7, lr}
 8008206:	b086      	sub	sp, #24
 8008208:	af00      	add	r7, sp, #0
 800820a:	6078      	str	r0, [r7, #4]
 800820c:	460b      	mov	r3, r1
 800820e:	70fb      	strb	r3, [r7, #3]
 8008210:	4613      	mov	r3, r2
 8008212:	70bb      	strb	r3, [r7, #2]
  GPIO_Handle_t USARTpins;
  USARTpins.pGPIOx = pGPIOx;
 8008214:	687b      	ldr	r3, [r7, #4]
 8008216:	60fb      	str	r3, [r7, #12]
  USARTpins.GPIO_PinConfig.GPIO_PinNumber =  PinNumber;
 8008218:	78fb      	ldrb	r3, [r7, #3]
 800821a:	743b      	strb	r3, [r7, #16]
  USARTpins.GPIO_PinConfig.GPIO_PinMode   =  GPIO_MODE_ALTFN;
 800821c:	2302      	movs	r3, #2
 800821e:	747b      	strb	r3, [r7, #17]
  USARTpins.GPIO_PinConfig.GPIO_PinAltFunMode   =  ALTFN_Mode;
 8008220:	78bb      	ldrb	r3, [r7, #2]
 8008222:	757b      	strb	r3, [r7, #21]
  USARTpins.GPIO_PinConfig.GPIO_PinOPType = GPIO_OP_TYPE_PP;
 8008224:	2300      	movs	r3, #0
 8008226:	753b      	strb	r3, [r7, #20]
  USARTpins.GPIO_PinConfig.GPIO_PinPuPdControl  = GPIO_PIN_PU;
 8008228:	2301      	movs	r3, #1
 800822a:	74fb      	strb	r3, [r7, #19]
  USARTpins.GPIO_PinConfig.GPIO_PinSpeed = GPOI_SPEED_HIGH;
 800822c:	2303      	movs	r3, #3
 800822e:	74bb      	strb	r3, [r7, #18]
  GPIO_CLKCNT(pGPIOx, ENABLE);
 8008230:	2101      	movs	r1, #1
 8008232:	6878      	ldr	r0, [r7, #4]
 8008234:	f000 f836 	bl	80082a4 <GPIO_CLKCNT>
  pGPIOx->LCKR &= ~(1 << PinNumber);
 8008238:	687b      	ldr	r3, [r7, #4]
 800823a:	69db      	ldr	r3, [r3, #28]
 800823c:	78fa      	ldrb	r2, [r7, #3]
 800823e:	2101      	movs	r1, #1
 8008240:	fa01 f202 	lsl.w	r2, r1, r2
 8008244:	43d2      	mvns	r2, r2
 8008246:	401a      	ands	r2, r3
 8008248:	687b      	ldr	r3, [r7, #4]
 800824a:	61da      	str	r2, [r3, #28]
  GPIO_Init(&USARTpins);
 800824c:	f107 030c 	add.w	r3, r7, #12
 8008250:	4618      	mov	r0, r3
 8008252:	f000 f90d 	bl	8008470 <GPIO_Init>
}
 8008256:	bf00      	nop
 8008258:	3718      	adds	r7, #24
 800825a:	46bd      	mov	sp, r7
 800825c:	bd80      	pop	{r7, pc}

0800825e <GPIO_ButtonInitIT>:
	  SW.GPIO_PinConfig.GPIO_PinOPType = GPIO_OP_TYPE_PP;
	  GPIO_CLKCNT(SW.pGPIOx, ENABLE);
	  GPIO_Init(&SW);
}

void GPIO_ButtonInitIT(GPIO_RegDef_t *pGPIOx, uint8_t PinNumber){
 800825e:	b580      	push	{r7, lr}
 8008260:	b086      	sub	sp, #24
 8008262:	af00      	add	r7, sp, #0
 8008264:	6078      	str	r0, [r7, #4]
 8008266:	460b      	mov	r3, r1
 8008268:	70fb      	strb	r3, [r7, #3]
	  GPIO_Handle_t SW;
	  SW.pGPIOx = pGPIOx;
 800826a:	687b      	ldr	r3, [r7, #4]
 800826c:	60fb      	str	r3, [r7, #12]
	  SW.GPIO_PinConfig.GPIO_PinNumber = PinNumber;
 800826e:	78fb      	ldrb	r3, [r7, #3]
 8008270:	743b      	strb	r3, [r7, #16]
	  SW.GPIO_PinConfig.GPIO_PinMode = GPIO_MODE_IT_FT;
 8008272:	2304      	movs	r3, #4
 8008274:	747b      	strb	r3, [r7, #17]
	  SW.GPIO_PinConfig.GPIO_PinOPType = GPIO_OP_TYPE_PP;
 8008276:	2300      	movs	r3, #0
 8008278:	753b      	strb	r3, [r7, #20]
	  SW.GPIO_PinConfig.GPIO_PinPuPdControl = GPIO_PIN_PU;
 800827a:	2301      	movs	r3, #1
 800827c:	74fb      	strb	r3, [r7, #19]
	  GPIO_CLKCNT(SW.pGPIOx, ENABLE);
 800827e:	68fb      	ldr	r3, [r7, #12]
 8008280:	2101      	movs	r1, #1
 8008282:	4618      	mov	r0, r3
 8008284:	f000 f80e 	bl	80082a4 <GPIO_CLKCNT>
	  GPIO_Init(&SW);
 8008288:	f107 030c 	add.w	r3, r7, #12
 800828c:	4618      	mov	r0, r3
 800828e:	f000 f8ef 	bl	8008470 <GPIO_Init>
	  GPIO_IRQInterruptConfig(IRQ_EXTI10_15, ENABLE);
 8008292:	2101      	movs	r1, #1
 8008294:	2028      	movs	r0, #40	; 0x28
 8008296:	f000 fa55 	bl	8008744 <GPIO_IRQInterruptConfig>
}
 800829a:	bf00      	nop
 800829c:	3718      	adds	r7, #24
 800829e:	46bd      	mov	sp, r7
 80082a0:	bd80      	pop	{r7, pc}
	...

080082a4 <GPIO_CLKCNT>:
 *
 * @Note              -  none

 */
void GPIO_CLKCNT(GPIO_RegDef_t *pGPIOx, uint8_t EnorDi)
{
 80082a4:	b480      	push	{r7}
 80082a6:	b083      	sub	sp, #12
 80082a8:	af00      	add	r7, sp, #0
 80082aa:	6078      	str	r0, [r7, #4]
 80082ac:	460b      	mov	r3, r1
 80082ae:	70fb      	strb	r3, [r7, #3]
	if(EnorDi == ENABLE)
 80082b0:	78fb      	ldrb	r3, [r7, #3]
 80082b2:	2b01      	cmp	r3, #1
 80082b4:	d157      	bne.n	8008366 <GPIO_CLKCNT+0xc2>
	{
	  if(pGPIOx == GPIOA){GPIOA_CLKEN;}
 80082b6:	687b      	ldr	r3, [r7, #4]
 80082b8:	4a59      	ldr	r2, [pc, #356]	; (8008420 <GPIO_CLKCNT+0x17c>)
 80082ba:	4293      	cmp	r3, r2
 80082bc:	d106      	bne.n	80082cc <GPIO_CLKCNT+0x28>
 80082be:	4b59      	ldr	r3, [pc, #356]	; (8008424 <GPIO_CLKCNT+0x180>)
 80082c0:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80082c2:	4a58      	ldr	r2, [pc, #352]	; (8008424 <GPIO_CLKCNT+0x180>)
 80082c4:	f043 0301 	orr.w	r3, r3, #1
 80082c8:	6313      	str	r3, [r2, #48]	; 0x30
	  else if (pGPIOx == GPIOE){GPIOE_CLKDI;}
	  else if (pGPIOx == GPIOF){GPIOF_CLKDI;}
	  else if (pGPIOx == GPIOG){GPIOG_CLKDI;}
	  else if (pGPIOx == GPIOH){GPIOH_CLKDI;}
	}
}
 80082ca:	e0a3      	b.n	8008414 <GPIO_CLKCNT+0x170>
	  else if (pGPIOx == GPIOB){GPIOB_CLKEN;}
 80082cc:	687b      	ldr	r3, [r7, #4]
 80082ce:	4a56      	ldr	r2, [pc, #344]	; (8008428 <GPIO_CLKCNT+0x184>)
 80082d0:	4293      	cmp	r3, r2
 80082d2:	d106      	bne.n	80082e2 <GPIO_CLKCNT+0x3e>
 80082d4:	4b53      	ldr	r3, [pc, #332]	; (8008424 <GPIO_CLKCNT+0x180>)
 80082d6:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80082d8:	4a52      	ldr	r2, [pc, #328]	; (8008424 <GPIO_CLKCNT+0x180>)
 80082da:	f043 0302 	orr.w	r3, r3, #2
 80082de:	6313      	str	r3, [r2, #48]	; 0x30
}
 80082e0:	e098      	b.n	8008414 <GPIO_CLKCNT+0x170>
	  else if (pGPIOx == GPIOC){GPIOC_CLKEN;}
 80082e2:	687b      	ldr	r3, [r7, #4]
 80082e4:	4a51      	ldr	r2, [pc, #324]	; (800842c <GPIO_CLKCNT+0x188>)
 80082e6:	4293      	cmp	r3, r2
 80082e8:	d106      	bne.n	80082f8 <GPIO_CLKCNT+0x54>
 80082ea:	4b4e      	ldr	r3, [pc, #312]	; (8008424 <GPIO_CLKCNT+0x180>)
 80082ec:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80082ee:	4a4d      	ldr	r2, [pc, #308]	; (8008424 <GPIO_CLKCNT+0x180>)
 80082f0:	f043 0304 	orr.w	r3, r3, #4
 80082f4:	6313      	str	r3, [r2, #48]	; 0x30
}
 80082f6:	e08d      	b.n	8008414 <GPIO_CLKCNT+0x170>
	  else if (pGPIOx == GPIOD){GPIOD_CLKEN;}
 80082f8:	687b      	ldr	r3, [r7, #4]
 80082fa:	4a4d      	ldr	r2, [pc, #308]	; (8008430 <GPIO_CLKCNT+0x18c>)
 80082fc:	4293      	cmp	r3, r2
 80082fe:	d106      	bne.n	800830e <GPIO_CLKCNT+0x6a>
 8008300:	4b48      	ldr	r3, [pc, #288]	; (8008424 <GPIO_CLKCNT+0x180>)
 8008302:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8008304:	4a47      	ldr	r2, [pc, #284]	; (8008424 <GPIO_CLKCNT+0x180>)
 8008306:	f043 0308 	orr.w	r3, r3, #8
 800830a:	6313      	str	r3, [r2, #48]	; 0x30
}
 800830c:	e082      	b.n	8008414 <GPIO_CLKCNT+0x170>
	  else if (pGPIOx == GPIOE){GPIOE_CLKEN;}
 800830e:	687b      	ldr	r3, [r7, #4]
 8008310:	4a48      	ldr	r2, [pc, #288]	; (8008434 <GPIO_CLKCNT+0x190>)
 8008312:	4293      	cmp	r3, r2
 8008314:	d106      	bne.n	8008324 <GPIO_CLKCNT+0x80>
 8008316:	4b43      	ldr	r3, [pc, #268]	; (8008424 <GPIO_CLKCNT+0x180>)
 8008318:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800831a:	4a42      	ldr	r2, [pc, #264]	; (8008424 <GPIO_CLKCNT+0x180>)
 800831c:	f043 0310 	orr.w	r3, r3, #16
 8008320:	6313      	str	r3, [r2, #48]	; 0x30
}
 8008322:	e077      	b.n	8008414 <GPIO_CLKCNT+0x170>
	  else if (pGPIOx == GPIOF){GPIOF_CLKEN;}
 8008324:	687b      	ldr	r3, [r7, #4]
 8008326:	4a44      	ldr	r2, [pc, #272]	; (8008438 <GPIO_CLKCNT+0x194>)
 8008328:	4293      	cmp	r3, r2
 800832a:	d106      	bne.n	800833a <GPIO_CLKCNT+0x96>
 800832c:	4b3d      	ldr	r3, [pc, #244]	; (8008424 <GPIO_CLKCNT+0x180>)
 800832e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8008330:	4a3c      	ldr	r2, [pc, #240]	; (8008424 <GPIO_CLKCNT+0x180>)
 8008332:	f043 0320 	orr.w	r3, r3, #32
 8008336:	6313      	str	r3, [r2, #48]	; 0x30
}
 8008338:	e06c      	b.n	8008414 <GPIO_CLKCNT+0x170>
	  else if (pGPIOx == GPIOG){GPIOG_CLKEN;}
 800833a:	687b      	ldr	r3, [r7, #4]
 800833c:	4a3f      	ldr	r2, [pc, #252]	; (800843c <GPIO_CLKCNT+0x198>)
 800833e:	4293      	cmp	r3, r2
 8008340:	d106      	bne.n	8008350 <GPIO_CLKCNT+0xac>
 8008342:	4b38      	ldr	r3, [pc, #224]	; (8008424 <GPIO_CLKCNT+0x180>)
 8008344:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8008346:	4a37      	ldr	r2, [pc, #220]	; (8008424 <GPIO_CLKCNT+0x180>)
 8008348:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 800834c:	6313      	str	r3, [r2, #48]	; 0x30
}
 800834e:	e061      	b.n	8008414 <GPIO_CLKCNT+0x170>
	  else if (pGPIOx == GPIOH){GPIOH_CLKEN;}
 8008350:	687b      	ldr	r3, [r7, #4]
 8008352:	4a3b      	ldr	r2, [pc, #236]	; (8008440 <GPIO_CLKCNT+0x19c>)
 8008354:	4293      	cmp	r3, r2
 8008356:	d15d      	bne.n	8008414 <GPIO_CLKCNT+0x170>
 8008358:	4b32      	ldr	r3, [pc, #200]	; (8008424 <GPIO_CLKCNT+0x180>)
 800835a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800835c:	4a31      	ldr	r2, [pc, #196]	; (8008424 <GPIO_CLKCNT+0x180>)
 800835e:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8008362:	6313      	str	r3, [r2, #48]	; 0x30
}
 8008364:	e056      	b.n	8008414 <GPIO_CLKCNT+0x170>
	  if(pGPIOx == GPIOA){GPIOA_CLKDI;}
 8008366:	687b      	ldr	r3, [r7, #4]
 8008368:	4a2d      	ldr	r2, [pc, #180]	; (8008420 <GPIO_CLKCNT+0x17c>)
 800836a:	4293      	cmp	r3, r2
 800836c:	d106      	bne.n	800837c <GPIO_CLKCNT+0xd8>
 800836e:	4b2d      	ldr	r3, [pc, #180]	; (8008424 <GPIO_CLKCNT+0x180>)
 8008370:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8008372:	4a2c      	ldr	r2, [pc, #176]	; (8008424 <GPIO_CLKCNT+0x180>)
 8008374:	f023 0301 	bic.w	r3, r3, #1
 8008378:	6313      	str	r3, [r2, #48]	; 0x30
}
 800837a:	e04b      	b.n	8008414 <GPIO_CLKCNT+0x170>
	  else if (pGPIOx == GPIOB){GPIOB_CLKDI;}
 800837c:	687b      	ldr	r3, [r7, #4]
 800837e:	4a2a      	ldr	r2, [pc, #168]	; (8008428 <GPIO_CLKCNT+0x184>)
 8008380:	4293      	cmp	r3, r2
 8008382:	d106      	bne.n	8008392 <GPIO_CLKCNT+0xee>
 8008384:	4b27      	ldr	r3, [pc, #156]	; (8008424 <GPIO_CLKCNT+0x180>)
 8008386:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8008388:	4a26      	ldr	r2, [pc, #152]	; (8008424 <GPIO_CLKCNT+0x180>)
 800838a:	f023 0302 	bic.w	r3, r3, #2
 800838e:	6313      	str	r3, [r2, #48]	; 0x30
}
 8008390:	e040      	b.n	8008414 <GPIO_CLKCNT+0x170>
	  else if (pGPIOx == GPIOC){GPIOC_CLKDI;}
 8008392:	687b      	ldr	r3, [r7, #4]
 8008394:	4a25      	ldr	r2, [pc, #148]	; (800842c <GPIO_CLKCNT+0x188>)
 8008396:	4293      	cmp	r3, r2
 8008398:	d106      	bne.n	80083a8 <GPIO_CLKCNT+0x104>
 800839a:	4b22      	ldr	r3, [pc, #136]	; (8008424 <GPIO_CLKCNT+0x180>)
 800839c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800839e:	4a21      	ldr	r2, [pc, #132]	; (8008424 <GPIO_CLKCNT+0x180>)
 80083a0:	f023 0304 	bic.w	r3, r3, #4
 80083a4:	6313      	str	r3, [r2, #48]	; 0x30
}
 80083a6:	e035      	b.n	8008414 <GPIO_CLKCNT+0x170>
	  else if (pGPIOx == GPIOD){GPIOD_CLKDI;}
 80083a8:	687b      	ldr	r3, [r7, #4]
 80083aa:	4a21      	ldr	r2, [pc, #132]	; (8008430 <GPIO_CLKCNT+0x18c>)
 80083ac:	4293      	cmp	r3, r2
 80083ae:	d106      	bne.n	80083be <GPIO_CLKCNT+0x11a>
 80083b0:	4b1c      	ldr	r3, [pc, #112]	; (8008424 <GPIO_CLKCNT+0x180>)
 80083b2:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80083b4:	4a1b      	ldr	r2, [pc, #108]	; (8008424 <GPIO_CLKCNT+0x180>)
 80083b6:	f023 0308 	bic.w	r3, r3, #8
 80083ba:	6313      	str	r3, [r2, #48]	; 0x30
}
 80083bc:	e02a      	b.n	8008414 <GPIO_CLKCNT+0x170>
	  else if (pGPIOx == GPIOE){GPIOE_CLKDI;}
 80083be:	687b      	ldr	r3, [r7, #4]
 80083c0:	4a1c      	ldr	r2, [pc, #112]	; (8008434 <GPIO_CLKCNT+0x190>)
 80083c2:	4293      	cmp	r3, r2
 80083c4:	d106      	bne.n	80083d4 <GPIO_CLKCNT+0x130>
 80083c6:	4b17      	ldr	r3, [pc, #92]	; (8008424 <GPIO_CLKCNT+0x180>)
 80083c8:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80083ca:	4a16      	ldr	r2, [pc, #88]	; (8008424 <GPIO_CLKCNT+0x180>)
 80083cc:	f023 0310 	bic.w	r3, r3, #16
 80083d0:	6313      	str	r3, [r2, #48]	; 0x30
}
 80083d2:	e01f      	b.n	8008414 <GPIO_CLKCNT+0x170>
	  else if (pGPIOx == GPIOF){GPIOF_CLKDI;}
 80083d4:	687b      	ldr	r3, [r7, #4]
 80083d6:	4a18      	ldr	r2, [pc, #96]	; (8008438 <GPIO_CLKCNT+0x194>)
 80083d8:	4293      	cmp	r3, r2
 80083da:	d106      	bne.n	80083ea <GPIO_CLKCNT+0x146>
 80083dc:	4b11      	ldr	r3, [pc, #68]	; (8008424 <GPIO_CLKCNT+0x180>)
 80083de:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80083e0:	4a10      	ldr	r2, [pc, #64]	; (8008424 <GPIO_CLKCNT+0x180>)
 80083e2:	f023 0320 	bic.w	r3, r3, #32
 80083e6:	6313      	str	r3, [r2, #48]	; 0x30
}
 80083e8:	e014      	b.n	8008414 <GPIO_CLKCNT+0x170>
	  else if (pGPIOx == GPIOG){GPIOG_CLKDI;}
 80083ea:	687b      	ldr	r3, [r7, #4]
 80083ec:	4a13      	ldr	r2, [pc, #76]	; (800843c <GPIO_CLKCNT+0x198>)
 80083ee:	4293      	cmp	r3, r2
 80083f0:	d106      	bne.n	8008400 <GPIO_CLKCNT+0x15c>
 80083f2:	4b0c      	ldr	r3, [pc, #48]	; (8008424 <GPIO_CLKCNT+0x180>)
 80083f4:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80083f6:	4a0b      	ldr	r2, [pc, #44]	; (8008424 <GPIO_CLKCNT+0x180>)
 80083f8:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 80083fc:	6313      	str	r3, [r2, #48]	; 0x30
}
 80083fe:	e009      	b.n	8008414 <GPIO_CLKCNT+0x170>
	  else if (pGPIOx == GPIOH){GPIOH_CLKDI;}
 8008400:	687b      	ldr	r3, [r7, #4]
 8008402:	4a0f      	ldr	r2, [pc, #60]	; (8008440 <GPIO_CLKCNT+0x19c>)
 8008404:	4293      	cmp	r3, r2
 8008406:	d105      	bne.n	8008414 <GPIO_CLKCNT+0x170>
 8008408:	4b06      	ldr	r3, [pc, #24]	; (8008424 <GPIO_CLKCNT+0x180>)
 800840a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800840c:	4a05      	ldr	r2, [pc, #20]	; (8008424 <GPIO_CLKCNT+0x180>)
 800840e:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 8008412:	6313      	str	r3, [r2, #48]	; 0x30
}
 8008414:	bf00      	nop
 8008416:	370c      	adds	r7, #12
 8008418:	46bd      	mov	sp, r7
 800841a:	bc80      	pop	{r7}
 800841c:	4770      	bx	lr
 800841e:	bf00      	nop
 8008420:	40020000 	.word	0x40020000
 8008424:	40023800 	.word	0x40023800
 8008428:	40020400 	.word	0x40020400
 800842c:	40020800 	.word	0x40020800
 8008430:	40020c00 	.word	0x40020c00
 8008434:	40021000 	.word	0x40021000
 8008438:	40021400 	.word	0x40021400
 800843c:	40021800 	.word	0x40021800
 8008440:	40021c00 	.word	0x40021c00

08008444 <GPIO_PORTCODE>:
 * @return            - the code of the given port
 *
 * @Note              -

 */
uint8_t GPIO_PORTCODE(GPIO_RegDef_t *pGPIOx){
 8008444:	b480      	push	{r7}
 8008446:	b085      	sub	sp, #20
 8008448:	af00      	add	r7, sp, #0
 800844a:	6078      	str	r0, [r7, #4]
	uint8_t volatile portcode;
	uint32_t offset = (uint32_t)((uint32_t)pGPIOx - GPIOA_BASEADDR); /*calculate the offset from the base address*/
 800844c:	687b      	ldr	r3, [r7, #4]
 800844e:	f103 433f 	add.w	r3, r3, #3204448256	; 0xbf000000
 8008452:	f503 037e 	add.w	r3, r3, #16646144	; 0xfe0000
 8008456:	60fb      	str	r3, [r7, #12]
	portcode = offset / 0x400;   /*portcode will range from 0 to 8 since the offset is a multiply of 400*/
 8008458:	68fb      	ldr	r3, [r7, #12]
 800845a:	0a9b      	lsrs	r3, r3, #10
 800845c:	b2db      	uxtb	r3, r3
 800845e:	72fb      	strb	r3, [r7, #11]
	return portcode;
 8008460:	7afb      	ldrb	r3, [r7, #11]
 8008462:	b2db      	uxtb	r3, r3
}
 8008464:	4618      	mov	r0, r3
 8008466:	3714      	adds	r7, #20
 8008468:	46bd      	mov	sp, r7
 800846a:	bc80      	pop	{r7}
 800846c:	4770      	bx	lr
	...

08008470 <GPIO_Init>:
 *
 * @Note              -

 */
void GPIO_Init(GPIO_Handle_t *pGPIOHandle)
{
 8008470:	b580      	push	{r7, lr}
 8008472:	b086      	sub	sp, #24
 8008474:	af00      	add	r7, sp, #0
 8008476:	6078      	str	r0, [r7, #4]
	 uint32_t temp=0; //temp. register
 8008478:	2300      	movs	r3, #0
 800847a:	617b      	str	r3, [r7, #20]
	//1 . configure the mode of gpio pin

	if(pGPIOHandle->GPIO_PinConfig.GPIO_PinMode <= GPIO_MODE_ANALOG)
 800847c:	687b      	ldr	r3, [r7, #4]
 800847e:	795b      	ldrb	r3, [r3, #5]
 8008480:	2b03      	cmp	r3, #3
 8008482:	d820      	bhi.n	80084c6 <GPIO_Init+0x56>
	{
		//the non interrupt mode
		temp = (pGPIOHandle->GPIO_PinConfig.GPIO_PinMode << (2 * pGPIOHandle->GPIO_PinConfig.GPIO_PinNumber ) );
 8008484:	687b      	ldr	r3, [r7, #4]
 8008486:	795b      	ldrb	r3, [r3, #5]
 8008488:	461a      	mov	r2, r3
 800848a:	687b      	ldr	r3, [r7, #4]
 800848c:	791b      	ldrb	r3, [r3, #4]
 800848e:	005b      	lsls	r3, r3, #1
 8008490:	fa02 f303 	lsl.w	r3, r2, r3
 8008494:	617b      	str	r3, [r7, #20]
		pGPIOHandle->pGPIOx->MODER &= ~( 0x3 << (2 * pGPIOHandle->GPIO_PinConfig.GPIO_PinNumber)); //clearing
 8008496:	687b      	ldr	r3, [r7, #4]
 8008498:	681b      	ldr	r3, [r3, #0]
 800849a:	681a      	ldr	r2, [r3, #0]
 800849c:	687b      	ldr	r3, [r7, #4]
 800849e:	791b      	ldrb	r3, [r3, #4]
 80084a0:	005b      	lsls	r3, r3, #1
 80084a2:	2103      	movs	r1, #3
 80084a4:	fa01 f303 	lsl.w	r3, r1, r3
 80084a8:	43db      	mvns	r3, r3
 80084aa:	4619      	mov	r1, r3
 80084ac:	687b      	ldr	r3, [r7, #4]
 80084ae:	681b      	ldr	r3, [r3, #0]
 80084b0:	400a      	ands	r2, r1
 80084b2:	601a      	str	r2, [r3, #0]
		pGPIOHandle->pGPIOx->MODER |= temp; //setting
 80084b4:	687b      	ldr	r3, [r7, #4]
 80084b6:	681b      	ldr	r3, [r3, #0]
 80084b8:	6819      	ldr	r1, [r3, #0]
 80084ba:	687b      	ldr	r3, [r7, #4]
 80084bc:	681b      	ldr	r3, [r3, #0]
 80084be:	697a      	ldr	r2, [r7, #20]
 80084c0:	430a      	orrs	r2, r1
 80084c2:	601a      	str	r2, [r3, #0]
 80084c4:	e08a      	b.n	80085dc <GPIO_Init+0x16c>

	}else
	{
		if(pGPIOHandle->GPIO_PinConfig.GPIO_PinMode == GPIO_MODE_IT_FT){
 80084c6:	687b      	ldr	r3, [r7, #4]
 80084c8:	795b      	ldrb	r3, [r3, #5]
 80084ca:	2b04      	cmp	r3, #4
 80084cc:	d11d      	bne.n	800850a <GPIO_Init+0x9a>
			/*configure the falling edge trigger register*/
			pGPIOHandle->pGPIOx->MODER &= ~( 0x0 << (2 * pGPIOHandle->GPIO_PinConfig.GPIO_PinNumber));
 80084ce:	687b      	ldr	r3, [r7, #4]
 80084d0:	681a      	ldr	r2, [r3, #0]
 80084d2:	687b      	ldr	r3, [r7, #4]
 80084d4:	681b      	ldr	r3, [r3, #0]
 80084d6:	6812      	ldr	r2, [r2, #0]
 80084d8:	601a      	str	r2, [r3, #0]
			EXTI ->RTSR &= ~(1 << pGPIOHandle->GPIO_PinConfig.GPIO_PinNumber);
 80084da:	4b8c      	ldr	r3, [pc, #560]	; (800870c <GPIO_Init+0x29c>)
 80084dc:	689b      	ldr	r3, [r3, #8]
 80084de:	687a      	ldr	r2, [r7, #4]
 80084e0:	7912      	ldrb	r2, [r2, #4]
 80084e2:	4611      	mov	r1, r2
 80084e4:	2201      	movs	r2, #1
 80084e6:	408a      	lsls	r2, r1
 80084e8:	43d2      	mvns	r2, r2
 80084ea:	4611      	mov	r1, r2
 80084ec:	4a87      	ldr	r2, [pc, #540]	; (800870c <GPIO_Init+0x29c>)
 80084ee:	400b      	ands	r3, r1
 80084f0:	6093      	str	r3, [r2, #8]
			EXTI ->FTSR |= (1 << pGPIOHandle->GPIO_PinConfig.GPIO_PinNumber);
 80084f2:	4b86      	ldr	r3, [pc, #536]	; (800870c <GPIO_Init+0x29c>)
 80084f4:	68db      	ldr	r3, [r3, #12]
 80084f6:	687a      	ldr	r2, [r7, #4]
 80084f8:	7912      	ldrb	r2, [r2, #4]
 80084fa:	4611      	mov	r1, r2
 80084fc:	2201      	movs	r2, #1
 80084fe:	408a      	lsls	r2, r1
 8008500:	4611      	mov	r1, r2
 8008502:	4a82      	ldr	r2, [pc, #520]	; (800870c <GPIO_Init+0x29c>)
 8008504:	430b      	orrs	r3, r1
 8008506:	60d3      	str	r3, [r2, #12]
 8008508:	e03d      	b.n	8008586 <GPIO_Init+0x116>
		}else if(pGPIOHandle->GPIO_PinConfig.GPIO_PinMode == GPIO_MODE_IT_RT){
 800850a:	687b      	ldr	r3, [r7, #4]
 800850c:	795b      	ldrb	r3, [r3, #5]
 800850e:	2b05      	cmp	r3, #5
 8008510:	d11d      	bne.n	800854e <GPIO_Init+0xde>
			/*configure the rising edge trigger register*/
			pGPIOHandle->pGPIOx->MODER &= ~( 0x0 << (2 * pGPIOHandle->GPIO_PinConfig.GPIO_PinNumber));
 8008512:	687b      	ldr	r3, [r7, #4]
 8008514:	681a      	ldr	r2, [r3, #0]
 8008516:	687b      	ldr	r3, [r7, #4]
 8008518:	681b      	ldr	r3, [r3, #0]
 800851a:	6812      	ldr	r2, [r2, #0]
 800851c:	601a      	str	r2, [r3, #0]
			EXTI ->FTSR &= ~(1 << pGPIOHandle->GPIO_PinConfig.GPIO_PinNumber);
 800851e:	4b7b      	ldr	r3, [pc, #492]	; (800870c <GPIO_Init+0x29c>)
 8008520:	68db      	ldr	r3, [r3, #12]
 8008522:	687a      	ldr	r2, [r7, #4]
 8008524:	7912      	ldrb	r2, [r2, #4]
 8008526:	4611      	mov	r1, r2
 8008528:	2201      	movs	r2, #1
 800852a:	408a      	lsls	r2, r1
 800852c:	43d2      	mvns	r2, r2
 800852e:	4611      	mov	r1, r2
 8008530:	4a76      	ldr	r2, [pc, #472]	; (800870c <GPIO_Init+0x29c>)
 8008532:	400b      	ands	r3, r1
 8008534:	60d3      	str	r3, [r2, #12]
			EXTI ->RTSR |= (1 << pGPIOHandle->GPIO_PinConfig.GPIO_PinNumber);
 8008536:	4b75      	ldr	r3, [pc, #468]	; (800870c <GPIO_Init+0x29c>)
 8008538:	689b      	ldr	r3, [r3, #8]
 800853a:	687a      	ldr	r2, [r7, #4]
 800853c:	7912      	ldrb	r2, [r2, #4]
 800853e:	4611      	mov	r1, r2
 8008540:	2201      	movs	r2, #1
 8008542:	408a      	lsls	r2, r1
 8008544:	4611      	mov	r1, r2
 8008546:	4a71      	ldr	r2, [pc, #452]	; (800870c <GPIO_Init+0x29c>)
 8008548:	430b      	orrs	r3, r1
 800854a:	6093      	str	r3, [r2, #8]
 800854c:	e01b      	b.n	8008586 <GPIO_Init+0x116>
		}
		else{
			/*configure the falling and rising edge trigger registers*/
			pGPIOHandle->pGPIOx->MODER &= ~( 0x0 << (2 * pGPIOHandle->GPIO_PinConfig.GPIO_PinNumber));
 800854e:	687b      	ldr	r3, [r7, #4]
 8008550:	681a      	ldr	r2, [r3, #0]
 8008552:	687b      	ldr	r3, [r7, #4]
 8008554:	681b      	ldr	r3, [r3, #0]
 8008556:	6812      	ldr	r2, [r2, #0]
 8008558:	601a      	str	r2, [r3, #0]
			EXTI ->FTSR |= (1 << pGPIOHandle->GPIO_PinConfig.GPIO_PinNumber);
 800855a:	4b6c      	ldr	r3, [pc, #432]	; (800870c <GPIO_Init+0x29c>)
 800855c:	68db      	ldr	r3, [r3, #12]
 800855e:	687a      	ldr	r2, [r7, #4]
 8008560:	7912      	ldrb	r2, [r2, #4]
 8008562:	4611      	mov	r1, r2
 8008564:	2201      	movs	r2, #1
 8008566:	408a      	lsls	r2, r1
 8008568:	4611      	mov	r1, r2
 800856a:	4a68      	ldr	r2, [pc, #416]	; (800870c <GPIO_Init+0x29c>)
 800856c:	430b      	orrs	r3, r1
 800856e:	60d3      	str	r3, [r2, #12]
			EXTI ->RTSR |= (1 << pGPIOHandle->GPIO_PinConfig.GPIO_PinNumber);
 8008570:	4b66      	ldr	r3, [pc, #408]	; (800870c <GPIO_Init+0x29c>)
 8008572:	689b      	ldr	r3, [r3, #8]
 8008574:	687a      	ldr	r2, [r7, #4]
 8008576:	7912      	ldrb	r2, [r2, #4]
 8008578:	4611      	mov	r1, r2
 800857a:	2201      	movs	r2, #1
 800857c:	408a      	lsls	r2, r1
 800857e:	4611      	mov	r1, r2
 8008580:	4a62      	ldr	r2, [pc, #392]	; (800870c <GPIO_Init+0x29c>)
 8008582:	430b      	orrs	r3, r1
 8008584:	6093      	str	r3, [r2, #8]
		}

		/*configure the gpio port selection(SYSCONFIG_EXTI register)*/
		uint8_t tmp1 = pGPIOHandle->GPIO_PinConfig.GPIO_PinNumber / 4;  /*which EXTICR to configure*/
 8008586:	687b      	ldr	r3, [r7, #4]
 8008588:	791b      	ldrb	r3, [r3, #4]
 800858a:	089b      	lsrs	r3, r3, #2
 800858c:	74fb      	strb	r3, [r7, #19]
		uint8_t tmp2 = pGPIOHandle->GPIO_PinConfig.GPIO_PinNumber % 4;  /*which Field of the EXTICR to configure*/
 800858e:	687b      	ldr	r3, [r7, #4]
 8008590:	791b      	ldrb	r3, [r3, #4]
 8008592:	f003 0303 	and.w	r3, r3, #3
 8008596:	74bb      	strb	r3, [r7, #18]
		uint8_t portcode = GPIO_PORTCODE(pGPIOHandle->pGPIOx);          /*the code that represents the port whoes pin is goning to trigger the interrupt*/
 8008598:	687b      	ldr	r3, [r7, #4]
 800859a:	681b      	ldr	r3, [r3, #0]
 800859c:	4618      	mov	r0, r3
 800859e:	f7ff ff51 	bl	8008444 <GPIO_PORTCODE>
 80085a2:	4603      	mov	r3, r0
 80085a4:	747b      	strb	r3, [r7, #17]
		RCC->APB2ENR |= (1U << 14);										/*Enable colock for SYSCFG*/
 80085a6:	4b5a      	ldr	r3, [pc, #360]	; (8008710 <GPIO_Init+0x2a0>)
 80085a8:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 80085aa:	4a59      	ldr	r2, [pc, #356]	; (8008710 <GPIO_Init+0x2a0>)
 80085ac:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 80085b0:	6453      	str	r3, [r2, #68]	; 0x44
		SYSCFG->EXTICR[tmp1] = (portcode << tmp2 * 4);                  /*every field is four bits wide so  we multiply by 4*/
 80085b2:	7c7a      	ldrb	r2, [r7, #17]
 80085b4:	7cbb      	ldrb	r3, [r7, #18]
 80085b6:	009b      	lsls	r3, r3, #2
 80085b8:	fa02 f103 	lsl.w	r1, r2, r3
 80085bc:	4a55      	ldr	r2, [pc, #340]	; (8008714 <GPIO_Init+0x2a4>)
 80085be:	7cfb      	ldrb	r3, [r7, #19]
 80085c0:	3302      	adds	r3, #2
 80085c2:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
		/*configure the exti interrupt delivery(interrupt mask register)*/
		EXTI ->IMR |= (1 << pGPIOHandle->GPIO_PinConfig.GPIO_PinNumber);
 80085c6:	4b51      	ldr	r3, [pc, #324]	; (800870c <GPIO_Init+0x29c>)
 80085c8:	681b      	ldr	r3, [r3, #0]
 80085ca:	687a      	ldr	r2, [r7, #4]
 80085cc:	7912      	ldrb	r2, [r2, #4]
 80085ce:	4611      	mov	r1, r2
 80085d0:	2201      	movs	r2, #1
 80085d2:	408a      	lsls	r2, r1
 80085d4:	4611      	mov	r1, r2
 80085d6:	4a4d      	ldr	r2, [pc, #308]	; (800870c <GPIO_Init+0x29c>)
 80085d8:	430b      	orrs	r3, r1
 80085da:	6013      	str	r3, [r2, #0]
	}

	//2. configure the speed
	temp = (pGPIOHandle->GPIO_PinConfig.GPIO_PinSpeed << ( 2 * pGPIOHandle->GPIO_PinConfig.GPIO_PinNumber) );
 80085dc:	687b      	ldr	r3, [r7, #4]
 80085de:	799b      	ldrb	r3, [r3, #6]
 80085e0:	461a      	mov	r2, r3
 80085e2:	687b      	ldr	r3, [r7, #4]
 80085e4:	791b      	ldrb	r3, [r3, #4]
 80085e6:	005b      	lsls	r3, r3, #1
 80085e8:	fa02 f303 	lsl.w	r3, r2, r3
 80085ec:	617b      	str	r3, [r7, #20]
	pGPIOHandle->pGPIOx->OSPEEDER &= ~( 0x3 << ( 2 * pGPIOHandle->GPIO_PinConfig.GPIO_PinNumber)); //clearing
 80085ee:	687b      	ldr	r3, [r7, #4]
 80085f0:	681b      	ldr	r3, [r3, #0]
 80085f2:	689a      	ldr	r2, [r3, #8]
 80085f4:	687b      	ldr	r3, [r7, #4]
 80085f6:	791b      	ldrb	r3, [r3, #4]
 80085f8:	005b      	lsls	r3, r3, #1
 80085fa:	2103      	movs	r1, #3
 80085fc:	fa01 f303 	lsl.w	r3, r1, r3
 8008600:	43db      	mvns	r3, r3
 8008602:	4619      	mov	r1, r3
 8008604:	687b      	ldr	r3, [r7, #4]
 8008606:	681b      	ldr	r3, [r3, #0]
 8008608:	400a      	ands	r2, r1
 800860a:	609a      	str	r2, [r3, #8]
	pGPIOHandle->pGPIOx->OSPEEDER |= temp;
 800860c:	687b      	ldr	r3, [r7, #4]
 800860e:	681b      	ldr	r3, [r3, #0]
 8008610:	6899      	ldr	r1, [r3, #8]
 8008612:	687b      	ldr	r3, [r7, #4]
 8008614:	681b      	ldr	r3, [r3, #0]
 8008616:	697a      	ldr	r2, [r7, #20]
 8008618:	430a      	orrs	r2, r1
 800861a:	609a      	str	r2, [r3, #8]

	//3. configure the pupd settings
	temp = (pGPIOHandle->GPIO_PinConfig.GPIO_PinPuPdControl << ( 2 * pGPIOHandle->GPIO_PinConfig.GPIO_PinNumber) );
 800861c:	687b      	ldr	r3, [r7, #4]
 800861e:	79db      	ldrb	r3, [r3, #7]
 8008620:	461a      	mov	r2, r3
 8008622:	687b      	ldr	r3, [r7, #4]
 8008624:	791b      	ldrb	r3, [r3, #4]
 8008626:	005b      	lsls	r3, r3, #1
 8008628:	fa02 f303 	lsl.w	r3, r2, r3
 800862c:	617b      	str	r3, [r7, #20]
	pGPIOHandle->pGPIOx->PUPDR &= ~( 0x3 << ( 2 * pGPIOHandle->GPIO_PinConfig.GPIO_PinNumber)); //clearing
 800862e:	687b      	ldr	r3, [r7, #4]
 8008630:	681b      	ldr	r3, [r3, #0]
 8008632:	68da      	ldr	r2, [r3, #12]
 8008634:	687b      	ldr	r3, [r7, #4]
 8008636:	791b      	ldrb	r3, [r3, #4]
 8008638:	005b      	lsls	r3, r3, #1
 800863a:	2103      	movs	r1, #3
 800863c:	fa01 f303 	lsl.w	r3, r1, r3
 8008640:	43db      	mvns	r3, r3
 8008642:	4619      	mov	r1, r3
 8008644:	687b      	ldr	r3, [r7, #4]
 8008646:	681b      	ldr	r3, [r3, #0]
 8008648:	400a      	ands	r2, r1
 800864a:	60da      	str	r2, [r3, #12]
	pGPIOHandle->pGPIOx->PUPDR |= temp;
 800864c:	687b      	ldr	r3, [r7, #4]
 800864e:	681b      	ldr	r3, [r3, #0]
 8008650:	68d9      	ldr	r1, [r3, #12]
 8008652:	687b      	ldr	r3, [r7, #4]
 8008654:	681b      	ldr	r3, [r3, #0]
 8008656:	697a      	ldr	r2, [r7, #20]
 8008658:	430a      	orrs	r2, r1
 800865a:	60da      	str	r2, [r3, #12]


	//4. configure the optype
	temp = (pGPIOHandle->GPIO_PinConfig.GPIO_PinOPType << pGPIOHandle->GPIO_PinConfig.GPIO_PinNumber );
 800865c:	687b      	ldr	r3, [r7, #4]
 800865e:	7a1b      	ldrb	r3, [r3, #8]
 8008660:	461a      	mov	r2, r3
 8008662:	687b      	ldr	r3, [r7, #4]
 8008664:	791b      	ldrb	r3, [r3, #4]
 8008666:	fa02 f303 	lsl.w	r3, r2, r3
 800866a:	617b      	str	r3, [r7, #20]
	pGPIOHandle->pGPIOx->OTYPER &= ~( 0x1 << pGPIOHandle->GPIO_PinConfig.GPIO_PinNumber); //clearing
 800866c:	687b      	ldr	r3, [r7, #4]
 800866e:	681b      	ldr	r3, [r3, #0]
 8008670:	685a      	ldr	r2, [r3, #4]
 8008672:	687b      	ldr	r3, [r7, #4]
 8008674:	791b      	ldrb	r3, [r3, #4]
 8008676:	4619      	mov	r1, r3
 8008678:	2301      	movs	r3, #1
 800867a:	408b      	lsls	r3, r1
 800867c:	43db      	mvns	r3, r3
 800867e:	4619      	mov	r1, r3
 8008680:	687b      	ldr	r3, [r7, #4]
 8008682:	681b      	ldr	r3, [r3, #0]
 8008684:	400a      	ands	r2, r1
 8008686:	605a      	str	r2, [r3, #4]
	pGPIOHandle->pGPIOx->OTYPER |= temp;
 8008688:	687b      	ldr	r3, [r7, #4]
 800868a:	681b      	ldr	r3, [r3, #0]
 800868c:	6859      	ldr	r1, [r3, #4]
 800868e:	687b      	ldr	r3, [r7, #4]
 8008690:	681b      	ldr	r3, [r3, #0]
 8008692:	697a      	ldr	r2, [r7, #20]
 8008694:	430a      	orrs	r2, r1
 8008696:	605a      	str	r2, [r3, #4]

	//5. configure the alt functionality
	if(pGPIOHandle->GPIO_PinConfig.GPIO_PinMode == GPIO_MODE_ALTFN)
 8008698:	687b      	ldr	r3, [r7, #4]
 800869a:	795b      	ldrb	r3, [r3, #5]
 800869c:	2b02      	cmp	r3, #2
 800869e:	d131      	bne.n	8008704 <GPIO_Init+0x294>
	{
		//configure the alt function registers.
		uint8_t temp1, temp2;
		temp1 = pGPIOHandle->GPIO_PinConfig.GPIO_PinNumber / 8;
 80086a0:	687b      	ldr	r3, [r7, #4]
 80086a2:	791b      	ldrb	r3, [r3, #4]
 80086a4:	08db      	lsrs	r3, r3, #3
 80086a6:	743b      	strb	r3, [r7, #16]
		temp2 = pGPIOHandle->GPIO_PinConfig.GPIO_PinNumber  % 8;
 80086a8:	687b      	ldr	r3, [r7, #4]
 80086aa:	791b      	ldrb	r3, [r3, #4]
 80086ac:	f003 0307 	and.w	r3, r3, #7
 80086b0:	73fb      	strb	r3, [r7, #15]
		pGPIOHandle->pGPIOx->AFR[temp1] &= ~(0xF << ( 4 * temp2 ) ); //clearing
 80086b2:	687b      	ldr	r3, [r7, #4]
 80086b4:	681b      	ldr	r3, [r3, #0]
 80086b6:	7c3a      	ldrb	r2, [r7, #16]
 80086b8:	3208      	adds	r2, #8
 80086ba:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
 80086be:	7bfb      	ldrb	r3, [r7, #15]
 80086c0:	009b      	lsls	r3, r3, #2
 80086c2:	220f      	movs	r2, #15
 80086c4:	fa02 f303 	lsl.w	r3, r2, r3
 80086c8:	43db      	mvns	r3, r3
 80086ca:	4618      	mov	r0, r3
 80086cc:	687b      	ldr	r3, [r7, #4]
 80086ce:	681b      	ldr	r3, [r3, #0]
 80086d0:	7c3a      	ldrb	r2, [r7, #16]
 80086d2:	4001      	ands	r1, r0
 80086d4:	3208      	adds	r2, #8
 80086d6:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
		pGPIOHandle->pGPIOx->AFR[temp1] |= (pGPIOHandle->GPIO_PinConfig.GPIO_PinAltFunMode << ( 4 * temp2 ) );
 80086da:	687b      	ldr	r3, [r7, #4]
 80086dc:	681b      	ldr	r3, [r3, #0]
 80086de:	7c3a      	ldrb	r2, [r7, #16]
 80086e0:	3208      	adds	r2, #8
 80086e2:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
 80086e6:	687b      	ldr	r3, [r7, #4]
 80086e8:	7a5b      	ldrb	r3, [r3, #9]
 80086ea:	461a      	mov	r2, r3
 80086ec:	7bfb      	ldrb	r3, [r7, #15]
 80086ee:	009b      	lsls	r3, r3, #2
 80086f0:	fa02 f303 	lsl.w	r3, r2, r3
 80086f4:	4618      	mov	r0, r3
 80086f6:	687b      	ldr	r3, [r7, #4]
 80086f8:	681b      	ldr	r3, [r3, #0]
 80086fa:	7c3a      	ldrb	r2, [r7, #16]
 80086fc:	4301      	orrs	r1, r0
 80086fe:	3208      	adds	r2, #8
 8008700:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
	}

}
 8008704:	bf00      	nop
 8008706:	3718      	adds	r7, #24
 8008708:	46bd      	mov	sp, r7
 800870a:	bd80      	pop	{r7, pc}
 800870c:	40013c00 	.word	0x40013c00
 8008710:	40023800 	.word	0x40023800
 8008714:	40013800 	.word	0x40013800

08008718 <GPIO_ReadFromInputPin>:
 *
 * @Note              -

 */
uint8_t GPIO_ReadFromInputPin(GPIO_RegDef_t *pGPIOx, uint8_t PinNumber)
{
 8008718:	b480      	push	{r7}
 800871a:	b085      	sub	sp, #20
 800871c:	af00      	add	r7, sp, #0
 800871e:	6078      	str	r0, [r7, #4]
 8008720:	460b      	mov	r3, r1
 8008722:	70fb      	strb	r3, [r7, #3]
   uint8_t value;

   value = (uint8_t )((pGPIOx->IDR  >> PinNumber) & 0x00000001 ) ;
 8008724:	687b      	ldr	r3, [r7, #4]
 8008726:	691a      	ldr	r2, [r3, #16]
 8008728:	78fb      	ldrb	r3, [r7, #3]
 800872a:	fa22 f303 	lsr.w	r3, r2, r3
 800872e:	b2db      	uxtb	r3, r3
 8008730:	f003 0301 	and.w	r3, r3, #1
 8008734:	73fb      	strb	r3, [r7, #15]

   return value;
 8008736:	7bfb      	ldrb	r3, [r7, #15]
}
 8008738:	4618      	mov	r0, r3
 800873a:	3714      	adds	r7, #20
 800873c:	46bd      	mov	sp, r7
 800873e:	bc80      	pop	{r7}
 8008740:	4770      	bx	lr
	...

08008744 <GPIO_IRQInterruptConfig>:
 *
 * @Note              -

 */
void GPIO_IRQInterruptConfig(uint8_t IRQNumber, uint8_t EnorDi)
{
 8008744:	b480      	push	{r7}
 8008746:	b083      	sub	sp, #12
 8008748:	af00      	add	r7, sp, #0
 800874a:	4603      	mov	r3, r0
 800874c:	460a      	mov	r2, r1
 800874e:	71fb      	strb	r3, [r7, #7]
 8008750:	4613      	mov	r3, r2
 8008752:	71bb      	strb	r3, [r7, #6]
if(EnorDi == ENABLE){
 8008754:	79bb      	ldrb	r3, [r7, #6]
 8008756:	2b01      	cmp	r3, #1
 8008758:	d133      	bne.n	80087c2 <GPIO_IRQInterruptConfig+0x7e>
	if(IRQNumber <= 31){
 800875a:	79fb      	ldrb	r3, [r7, #7]
 800875c:	2b1f      	cmp	r3, #31
 800875e:	d80a      	bhi.n	8008776 <GPIO_IRQInterruptConfig+0x32>
		/*configure ISER0*/
		*ISER0 |= (1 << IRQNumber);
 8008760:	4b34      	ldr	r3, [pc, #208]	; (8008834 <GPIO_IRQInterruptConfig+0xf0>)
 8008762:	681b      	ldr	r3, [r3, #0]
 8008764:	79fa      	ldrb	r2, [r7, #7]
 8008766:	2101      	movs	r1, #1
 8008768:	fa01 f202 	lsl.w	r2, r1, r2
 800876c:	4611      	mov	r1, r2
 800876e:	4a31      	ldr	r2, [pc, #196]	; (8008834 <GPIO_IRQInterruptConfig+0xf0>)
 8008770:	430b      	orrs	r3, r1
 8008772:	6013      	str	r3, [r2, #0]
		*ICER1 |= (1 << (IRQNumber % 32));
	}else if(IRQNumber >= 64 && IRQNumber < 96){
		*ICER2 |= (1 << (IRQNumber % 64));
	}
}
}
 8008774:	e059      	b.n	800882a <GPIO_IRQInterruptConfig+0xe6>
	}else if(IRQNumber >= 32 && IRQNumber < 64){
 8008776:	79fb      	ldrb	r3, [r7, #7]
 8008778:	2b1f      	cmp	r3, #31
 800877a:	d90f      	bls.n	800879c <GPIO_IRQInterruptConfig+0x58>
 800877c:	79fb      	ldrb	r3, [r7, #7]
 800877e:	2b3f      	cmp	r3, #63	; 0x3f
 8008780:	d80c      	bhi.n	800879c <GPIO_IRQInterruptConfig+0x58>
		*ISER1 |= (1 << (IRQNumber % 32));
 8008782:	4b2d      	ldr	r3, [pc, #180]	; (8008838 <GPIO_IRQInterruptConfig+0xf4>)
 8008784:	681b      	ldr	r3, [r3, #0]
 8008786:	79fa      	ldrb	r2, [r7, #7]
 8008788:	f002 021f 	and.w	r2, r2, #31
 800878c:	2101      	movs	r1, #1
 800878e:	fa01 f202 	lsl.w	r2, r1, r2
 8008792:	4611      	mov	r1, r2
 8008794:	4a28      	ldr	r2, [pc, #160]	; (8008838 <GPIO_IRQInterruptConfig+0xf4>)
 8008796:	430b      	orrs	r3, r1
 8008798:	6013      	str	r3, [r2, #0]
 800879a:	e046      	b.n	800882a <GPIO_IRQInterruptConfig+0xe6>
	}else if(IRQNumber >= 64 && IRQNumber < 96){
 800879c:	79fb      	ldrb	r3, [r7, #7]
 800879e:	2b3f      	cmp	r3, #63	; 0x3f
 80087a0:	d943      	bls.n	800882a <GPIO_IRQInterruptConfig+0xe6>
 80087a2:	79fb      	ldrb	r3, [r7, #7]
 80087a4:	2b5f      	cmp	r3, #95	; 0x5f
 80087a6:	d840      	bhi.n	800882a <GPIO_IRQInterruptConfig+0xe6>
		*ISER2 |= (1 << (IRQNumber % 64));
 80087a8:	4b24      	ldr	r3, [pc, #144]	; (800883c <GPIO_IRQInterruptConfig+0xf8>)
 80087aa:	681b      	ldr	r3, [r3, #0]
 80087ac:	79fa      	ldrb	r2, [r7, #7]
 80087ae:	f002 023f 	and.w	r2, r2, #63	; 0x3f
 80087b2:	2101      	movs	r1, #1
 80087b4:	fa01 f202 	lsl.w	r2, r1, r2
 80087b8:	4611      	mov	r1, r2
 80087ba:	4a20      	ldr	r2, [pc, #128]	; (800883c <GPIO_IRQInterruptConfig+0xf8>)
 80087bc:	430b      	orrs	r3, r1
 80087be:	6013      	str	r3, [r2, #0]
}
 80087c0:	e033      	b.n	800882a <GPIO_IRQInterruptConfig+0xe6>
	if(IRQNumber <= 31){
 80087c2:	79fb      	ldrb	r3, [r7, #7]
 80087c4:	2b1f      	cmp	r3, #31
 80087c6:	d80a      	bhi.n	80087de <GPIO_IRQInterruptConfig+0x9a>
		*ICER0 |= (1 << IRQNumber);
 80087c8:	4b1d      	ldr	r3, [pc, #116]	; (8008840 <GPIO_IRQInterruptConfig+0xfc>)
 80087ca:	681b      	ldr	r3, [r3, #0]
 80087cc:	79fa      	ldrb	r2, [r7, #7]
 80087ce:	2101      	movs	r1, #1
 80087d0:	fa01 f202 	lsl.w	r2, r1, r2
 80087d4:	4611      	mov	r1, r2
 80087d6:	4a1a      	ldr	r2, [pc, #104]	; (8008840 <GPIO_IRQInterruptConfig+0xfc>)
 80087d8:	430b      	orrs	r3, r1
 80087da:	6013      	str	r3, [r2, #0]
}
 80087dc:	e025      	b.n	800882a <GPIO_IRQInterruptConfig+0xe6>
	}else if(IRQNumber >= 32 && IRQNumber < 64){
 80087de:	79fb      	ldrb	r3, [r7, #7]
 80087e0:	2b1f      	cmp	r3, #31
 80087e2:	d90f      	bls.n	8008804 <GPIO_IRQInterruptConfig+0xc0>
 80087e4:	79fb      	ldrb	r3, [r7, #7]
 80087e6:	2b3f      	cmp	r3, #63	; 0x3f
 80087e8:	d80c      	bhi.n	8008804 <GPIO_IRQInterruptConfig+0xc0>
		*ICER1 |= (1 << (IRQNumber % 32));
 80087ea:	4b16      	ldr	r3, [pc, #88]	; (8008844 <GPIO_IRQInterruptConfig+0x100>)
 80087ec:	681b      	ldr	r3, [r3, #0]
 80087ee:	79fa      	ldrb	r2, [r7, #7]
 80087f0:	f002 021f 	and.w	r2, r2, #31
 80087f4:	2101      	movs	r1, #1
 80087f6:	fa01 f202 	lsl.w	r2, r1, r2
 80087fa:	4611      	mov	r1, r2
 80087fc:	4a11      	ldr	r2, [pc, #68]	; (8008844 <GPIO_IRQInterruptConfig+0x100>)
 80087fe:	430b      	orrs	r3, r1
 8008800:	6013      	str	r3, [r2, #0]
 8008802:	e012      	b.n	800882a <GPIO_IRQInterruptConfig+0xe6>
	}else if(IRQNumber >= 64 && IRQNumber < 96){
 8008804:	79fb      	ldrb	r3, [r7, #7]
 8008806:	2b3f      	cmp	r3, #63	; 0x3f
 8008808:	d90f      	bls.n	800882a <GPIO_IRQInterruptConfig+0xe6>
 800880a:	79fb      	ldrb	r3, [r7, #7]
 800880c:	2b5f      	cmp	r3, #95	; 0x5f
 800880e:	d80c      	bhi.n	800882a <GPIO_IRQInterruptConfig+0xe6>
		*ICER2 |= (1 << (IRQNumber % 64));
 8008810:	4b0d      	ldr	r3, [pc, #52]	; (8008848 <GPIO_IRQInterruptConfig+0x104>)
 8008812:	681b      	ldr	r3, [r3, #0]
 8008814:	79fa      	ldrb	r2, [r7, #7]
 8008816:	f002 023f 	and.w	r2, r2, #63	; 0x3f
 800881a:	2101      	movs	r1, #1
 800881c:	fa01 f202 	lsl.w	r2, r1, r2
 8008820:	4611      	mov	r1, r2
 8008822:	4a09      	ldr	r2, [pc, #36]	; (8008848 <GPIO_IRQInterruptConfig+0x104>)
 8008824:	430b      	orrs	r3, r1
 8008826:	6013      	str	r3, [r2, #0]
}
 8008828:	e7ff      	b.n	800882a <GPIO_IRQInterruptConfig+0xe6>
 800882a:	bf00      	nop
 800882c:	370c      	adds	r7, #12
 800882e:	46bd      	mov	sp, r7
 8008830:	bc80      	pop	{r7}
 8008832:	4770      	bx	lr
 8008834:	e000e100 	.word	0xe000e100
 8008838:	e000e104 	.word	0xe000e104
 800883c:	e000e108 	.word	0xe000e108
 8008840:	e000e180 	.word	0xe000e180
 8008844:	e000e184 	.word	0xe000e184
 8008848:	e000e188 	.word	0xe000e188

0800884c <getSystemClock>:
#include "RCC_driver.h"

uint16_t AHB_PRESCALERS[8] = {2, 4, 8, 16, 64, 128, 256, 512};
uint16_t APB_PRESCALERS[4] = {2, 4, 8, 16};

uint32_t getSystemClock(void){
 800884c:	b480      	push	{r7}
 800884e:	b087      	sub	sp, #28
 8008850:	af00      	add	r7, sp, #0
uint8_t PLLP1 = ((RCC->PLLCFGR >> 16) & 0x3U);
 8008852:	4b33      	ldr	r3, [pc, #204]	; (8008920 <getSystemClock+0xd4>)
 8008854:	685b      	ldr	r3, [r3, #4]
 8008856:	0c1b      	lsrs	r3, r3, #16
 8008858:	b2db      	uxtb	r3, r3
 800885a:	f003 0303 	and.w	r3, r3, #3
 800885e:	75bb      	strb	r3, [r7, #22]
uint8_t PLLP;
uint32_t fPLL,fPLLR;
switch(PLLP1){
 8008860:	7dbb      	ldrb	r3, [r7, #22]
 8008862:	2b03      	cmp	r3, #3
 8008864:	d816      	bhi.n	8008894 <getSystemClock+0x48>
 8008866:	a201      	add	r2, pc, #4	; (adr r2, 800886c <getSystemClock+0x20>)
 8008868:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800886c:	0800887d 	.word	0x0800887d
 8008870:	08008883 	.word	0x08008883
 8008874:	08008889 	.word	0x08008889
 8008878:	0800888f 	.word	0x0800888f
  case(0):
		  PLLP = 2;
 800887c:	2302      	movs	r3, #2
 800887e:	75fb      	strb	r3, [r7, #23]
          break;
 8008880:	e008      	b.n	8008894 <getSystemClock+0x48>
  case(1):
		  PLLP = 4;
 8008882:	2304      	movs	r3, #4
 8008884:	75fb      	strb	r3, [r7, #23]
          break;
 8008886:	e005      	b.n	8008894 <getSystemClock+0x48>
  case(2):
		  PLLP = 6;
 8008888:	2306      	movs	r3, #6
 800888a:	75fb      	strb	r3, [r7, #23]
          break;
 800888c:	e002      	b.n	8008894 <getSystemClock+0x48>
  case(3):
		  PLLP = 8;
 800888e:	2308      	movs	r3, #8
 8008890:	75fb      	strb	r3, [r7, #23]
          break;
 8008892:	bf00      	nop
}
uint16_t PLLN = ((RCC ->PLLCFGR >> 6) & 0x1FF);
 8008894:	4b22      	ldr	r3, [pc, #136]	; (8008920 <getSystemClock+0xd4>)
 8008896:	685b      	ldr	r3, [r3, #4]
 8008898:	099b      	lsrs	r3, r3, #6
 800889a:	b29b      	uxth	r3, r3
 800889c:	f3c3 0308 	ubfx	r3, r3, #0, #9
 80088a0:	82bb      	strh	r3, [r7, #20]
uint16_t PLLM = (RCC ->PLLCFGR & 0x3FU);
 80088a2:	4b1f      	ldr	r3, [pc, #124]	; (8008920 <getSystemClock+0xd4>)
 80088a4:	685b      	ldr	r3, [r3, #4]
 80088a6:	b29b      	uxth	r3, r3
 80088a8:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 80088ac:	827b      	strh	r3, [r7, #18]
uint16_t PLLR = (RCC ->PLLCFGR >> 28) & 0x7U;
 80088ae:	4b1c      	ldr	r3, [pc, #112]	; (8008920 <getSystemClock+0xd4>)
 80088b0:	685b      	ldr	r3, [r3, #4]
 80088b2:	0f1b      	lsrs	r3, r3, #28
 80088b4:	b29b      	uxth	r3, r3
 80088b6:	f003 0307 	and.w	r3, r3, #7
 80088ba:	823b      	strh	r3, [r7, #16]
uint32_t fVCO = HSI_CLOCK * (PLLN / PLLM); /*HSI is used as pll input*/
 80088bc:	8aba      	ldrh	r2, [r7, #20]
 80088be:	8a7b      	ldrh	r3, [r7, #18]
 80088c0:	fbb2 f3f3 	udiv	r3, r2, r3
 80088c4:	b29b      	uxth	r3, r3
 80088c6:	461a      	mov	r2, r3
 80088c8:	4b16      	ldr	r3, [pc, #88]	; (8008924 <getSystemClock+0xd8>)
 80088ca:	fb02 f303 	mul.w	r3, r2, r3
 80088ce:	60fb      	str	r3, [r7, #12]
	switch (RCC ->CFGR >> 2){
 80088d0:	4b13      	ldr	r3, [pc, #76]	; (8008920 <getSystemClock+0xd4>)
 80088d2:	689b      	ldr	r3, [r3, #8]
 80088d4:	089b      	lsrs	r3, r3, #2
 80088d6:	2b03      	cmp	r3, #3
 80088d8:	d81c      	bhi.n	8008914 <getSystemClock+0xc8>
 80088da:	a201      	add	r2, pc, #4	; (adr r2, 80088e0 <getSystemClock+0x94>)
 80088dc:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 80088e0:	080088f1 	.word	0x080088f1
 80088e4:	080088f5 	.word	0x080088f5
 80088e8:	080088f9 	.word	0x080088f9
 80088ec:	08008907 	.word	0x08008907
		case(0) : /*HSI is used*/
			return HSI_CLOCK; /*HSI clock speed*/
 80088f0:	4b0c      	ldr	r3, [pc, #48]	; (8008924 <getSystemClock+0xd8>)
 80088f2:	e00f      	b.n	8008914 <getSystemClock+0xc8>
		case(1) : /*HSE is used*/
			return HSE_CLOCK;
 80088f4:	4b0c      	ldr	r3, [pc, #48]	; (8008928 <getSystemClock+0xdc>)
 80088f6:	e00d      	b.n	8008914 <getSystemClock+0xc8>
		case(2) : /*PLL is used*/
		   fPLL = fVCO * PLLP;
 80088f8:	7dfa      	ldrb	r2, [r7, #23]
 80088fa:	68fb      	ldr	r3, [r7, #12]
 80088fc:	fb02 f303 	mul.w	r3, r2, r3
 8008900:	607b      	str	r3, [r7, #4]
		  return fPLL;
 8008902:	687b      	ldr	r3, [r7, #4]
 8008904:	e006      	b.n	8008914 <getSystemClock+0xc8>
		case(3) : /*PLL_R is used*/
			/*Clock frequancy = VCO / PLLR*/
			 fPLLR = fVCO / PLLR;
 8008906:	8a3b      	ldrh	r3, [r7, #16]
 8008908:	68fa      	ldr	r2, [r7, #12]
 800890a:	fbb2 f3f3 	udiv	r3, r2, r3
 800890e:	60bb      	str	r3, [r7, #8]
			return fPLLR;
 8008910:	68bb      	ldr	r3, [r7, #8]
 8008912:	e7ff      	b.n	8008914 <getSystemClock+0xc8>
	}
}
 8008914:	4618      	mov	r0, r3
 8008916:	371c      	adds	r7, #28
 8008918:	46bd      	mov	sp, r7
 800891a:	bc80      	pop	{r7}
 800891c:	4770      	bx	lr
 800891e:	bf00      	nop
 8008920:	40023800 	.word	0x40023800
 8008924:	00f42400 	.word	0x00f42400
 8008928:	007a1200 	.word	0x007a1200

0800892c <getAPBClock>:
	}
	uint32_t AHBClock = SystemClock / AHB_PRESCALER;
	return AHBClock;
}

uint32_t getAPBClock(uint32_t BusAddress){
 800892c:	b580      	push	{r7, lr}
 800892e:	b084      	sub	sp, #16
 8008930:	af00      	add	r7, sp, #0
 8008932:	6078      	str	r0, [r7, #4]
	if(BusAddress == APB1PREF_BASEADDR){
 8008934:	687b      	ldr	r3, [r7, #4]
 8008936:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 800893a:	d11a      	bne.n	8008972 <getAPBClock+0x46>
		uint8_t APB1PRESCALER;
		if(((RCC ->CFGR >> 10) & 0x7U) < 4){
 800893c:	4b1c      	ldr	r3, [pc, #112]	; (80089b0 <getAPBClock+0x84>)
 800893e:	689b      	ldr	r3, [r3, #8]
 8008940:	0a9b      	lsrs	r3, r3, #10
 8008942:	f003 0304 	and.w	r3, r3, #4
 8008946:	2b00      	cmp	r3, #0
 8008948:	d102      	bne.n	8008950 <getAPBClock+0x24>
		  APB1PRESCALER = 1;
 800894a:	2301      	movs	r3, #1
 800894c:	73fb      	strb	r3, [r7, #15]
 800894e:	e009      	b.n	8008964 <getAPBClock+0x38>
		}else{
		  APB1PRESCALER = APB_PRESCALERS[((RCC ->CFGR >> 10) & 0x7U) - 4];
 8008950:	4b17      	ldr	r3, [pc, #92]	; (80089b0 <getAPBClock+0x84>)
 8008952:	689b      	ldr	r3, [r3, #8]
 8008954:	0a9b      	lsrs	r3, r3, #10
 8008956:	f003 0307 	and.w	r3, r3, #7
 800895a:	3b04      	subs	r3, #4
 800895c:	4a15      	ldr	r2, [pc, #84]	; (80089b4 <getAPBClock+0x88>)
 800895e:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
 8008962:	73fb      	strb	r3, [r7, #15]
		}
		return (getSystemClock() / APB1PRESCALER);
 8008964:	f7ff ff72 	bl	800884c <getSystemClock>
 8008968:	4602      	mov	r2, r0
 800896a:	7bfb      	ldrb	r3, [r7, #15]
 800896c:	fbb2 f3f3 	udiv	r3, r2, r3
 8008970:	e019      	b.n	80089a6 <getAPBClock+0x7a>
	}
	else{
		uint8_t APB2PRESCALER;
		if(((RCC ->CFGR >> 13) & 0x7U) < 4){
 8008972:	4b0f      	ldr	r3, [pc, #60]	; (80089b0 <getAPBClock+0x84>)
 8008974:	689b      	ldr	r3, [r3, #8]
 8008976:	0b5b      	lsrs	r3, r3, #13
 8008978:	f003 0304 	and.w	r3, r3, #4
 800897c:	2b00      	cmp	r3, #0
 800897e:	d102      	bne.n	8008986 <getAPBClock+0x5a>
		  APB2PRESCALER = 1;
 8008980:	2301      	movs	r3, #1
 8008982:	73bb      	strb	r3, [r7, #14]
 8008984:	e009      	b.n	800899a <getAPBClock+0x6e>
		}else{
		  APB2PRESCALER = APB_PRESCALERS[((RCC ->CFGR >> 10) & 0x7U) - 4];
 8008986:	4b0a      	ldr	r3, [pc, #40]	; (80089b0 <getAPBClock+0x84>)
 8008988:	689b      	ldr	r3, [r3, #8]
 800898a:	0a9b      	lsrs	r3, r3, #10
 800898c:	f003 0307 	and.w	r3, r3, #7
 8008990:	3b04      	subs	r3, #4
 8008992:	4a08      	ldr	r2, [pc, #32]	; (80089b4 <getAPBClock+0x88>)
 8008994:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
 8008998:	73bb      	strb	r3, [r7, #14]
		}
		return (getSystemClock() / APB2PRESCALER);
 800899a:	f7ff ff57 	bl	800884c <getSystemClock>
 800899e:	4602      	mov	r2, r0
 80089a0:	7bbb      	ldrb	r3, [r7, #14]
 80089a2:	fbb2 f3f3 	udiv	r3, r2, r3
	}
}
 80089a6:	4618      	mov	r0, r3
 80089a8:	3710      	adds	r7, #16
 80089aa:	46bd      	mov	sp, r7
 80089ac:	bd80      	pop	{r7, pc}
 80089ae:	bf00      	nop
 80089b0:	40023800 	.word	0x40023800
 80089b4:	20000000 	.word	0x20000000

080089b8 <USART_SetBaudRate>:
 *
 * @Note              -

 */
void USART_SetBaudRate(USART_type *pUSARTx, uint32_t BaudRate)
{
 80089b8:	b580      	push	{r7, lr}
 80089ba:	b088      	sub	sp, #32
 80089bc:	af00      	add	r7, sp, #0
 80089be:	6078      	str	r0, [r7, #4]
 80089c0:	6039      	str	r1, [r7, #0]
	uint32_t usartdiv;

	//variables to hold Mantissa and Fraction values
	uint32_t M_part,F_part;

  uint32_t tempreg=0;
 80089c2:	2300      	movs	r3, #0
 80089c4:	613b      	str	r3, [r7, #16]

  //Get the value of APB bus clock in to the variable PCLKx
  if(pUSARTx == USART1 || pUSARTx == USART6)
 80089c6:	687b      	ldr	r3, [r7, #4]
 80089c8:	4a32      	ldr	r2, [pc, #200]	; (8008a94 <USART_SetBaudRate+0xdc>)
 80089ca:	4293      	cmp	r3, r2
 80089cc:	d003      	beq.n	80089d6 <USART_SetBaudRate+0x1e>
 80089ce:	687b      	ldr	r3, [r7, #4]
 80089d0:	4a31      	ldr	r2, [pc, #196]	; (8008a98 <USART_SetBaudRate+0xe0>)
 80089d2:	4293      	cmp	r3, r2
 80089d4:	d104      	bne.n	80089e0 <USART_SetBaudRate+0x28>
  {
	   //USART1 and USART6 are hanging on APB2 bus
	   PCLKx = getAPBClock(APB2PREF_BASEADDR);
 80089d6:	4831      	ldr	r0, [pc, #196]	; (8008a9c <USART_SetBaudRate+0xe4>)
 80089d8:	f7ff ffa8 	bl	800892c <getAPBClock>
 80089dc:	61f8      	str	r0, [r7, #28]
 80089de:	e004      	b.n	80089ea <USART_SetBaudRate+0x32>
  }else
  {
	  PCLKx = getAPBClock(APB1PREF_BASEADDR);
 80089e0:	f04f 4080 	mov.w	r0, #1073741824	; 0x40000000
 80089e4:	f7ff ffa2 	bl	800892c <getAPBClock>
 80089e8:	61f8      	str	r0, [r7, #28]
  }

  //Check for OVER8 configuration bit
  if(pUSARTx->CR1 & (1 << USART_CR1_OVER8))
 80089ea:	687b      	ldr	r3, [r7, #4]
 80089ec:	68db      	ldr	r3, [r3, #12]
 80089ee:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
 80089f2:	2b00      	cmp	r3, #0
 80089f4:	d00b      	beq.n	8008a0e <USART_SetBaudRate+0x56>
  {
	   //OVER8 = 1 , over sampling by 8
	   usartdiv = ((25 * PCLKx) / (2 *BaudRate));
 80089f6:	69fa      	ldr	r2, [r7, #28]
 80089f8:	4613      	mov	r3, r2
 80089fa:	009b      	lsls	r3, r3, #2
 80089fc:	4413      	add	r3, r2
 80089fe:	009a      	lsls	r2, r3, #2
 8008a00:	441a      	add	r2, r3
 8008a02:	683b      	ldr	r3, [r7, #0]
 8008a04:	005b      	lsls	r3, r3, #1
 8008a06:	fbb2 f3f3 	udiv	r3, r2, r3
 8008a0a:	61bb      	str	r3, [r7, #24]
 8008a0c:	e00a      	b.n	8008a24 <USART_SetBaudRate+0x6c>
  }else
  {
	   //over sampling by 16
	   usartdiv = ((25 * PCLKx) / (4 *BaudRate));
 8008a0e:	69fa      	ldr	r2, [r7, #28]
 8008a10:	4613      	mov	r3, r2
 8008a12:	009b      	lsls	r3, r3, #2
 8008a14:	4413      	add	r3, r2
 8008a16:	009a      	lsls	r2, r3, #2
 8008a18:	441a      	add	r2, r3
 8008a1a:	683b      	ldr	r3, [r7, #0]
 8008a1c:	009b      	lsls	r3, r3, #2
 8008a1e:	fbb2 f3f3 	udiv	r3, r2, r3
 8008a22:	61bb      	str	r3, [r7, #24]
  }

  //Calculate the Mantissa part
  M_part = usartdiv/100;
 8008a24:	69bb      	ldr	r3, [r7, #24]
 8008a26:	4a1e      	ldr	r2, [pc, #120]	; (8008aa0 <USART_SetBaudRate+0xe8>)
 8008a28:	fba2 2303 	umull	r2, r3, r2, r3
 8008a2c:	095b      	lsrs	r3, r3, #5
 8008a2e:	60fb      	str	r3, [r7, #12]

  //Place the Mantissa part in appropriate bit position . refer USART_BRR
  tempreg |= M_part << 4;
 8008a30:	68fb      	ldr	r3, [r7, #12]
 8008a32:	011b      	lsls	r3, r3, #4
 8008a34:	693a      	ldr	r2, [r7, #16]
 8008a36:	4313      	orrs	r3, r2
 8008a38:	613b      	str	r3, [r7, #16]

  //Extract the fraction part
  F_part = (usartdiv - (M_part * 100));
 8008a3a:	68fb      	ldr	r3, [r7, #12]
 8008a3c:	2264      	movs	r2, #100	; 0x64
 8008a3e:	fb02 f303 	mul.w	r3, r2, r3
 8008a42:	69ba      	ldr	r2, [r7, #24]
 8008a44:	1ad3      	subs	r3, r2, r3
 8008a46:	617b      	str	r3, [r7, #20]

  //Calculate the final fractional
  if(pUSARTx->CR1 & ( 1 << USART_CR1_OVER8))
 8008a48:	687b      	ldr	r3, [r7, #4]
 8008a4a:	68db      	ldr	r3, [r3, #12]
 8008a4c:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
 8008a50:	2b00      	cmp	r3, #0
 8008a52:	d00a      	beq.n	8008a6a <USART_SetBaudRate+0xb2>
   {
	  //OVER8 = 1 , over sampling by 8
	  F_part = ((( F_part * 8)+ 50) / 100)& ((uint8_t)0x07);
 8008a54:	697b      	ldr	r3, [r7, #20]
 8008a56:	00db      	lsls	r3, r3, #3
 8008a58:	3332      	adds	r3, #50	; 0x32
 8008a5a:	4a11      	ldr	r2, [pc, #68]	; (8008aa0 <USART_SetBaudRate+0xe8>)
 8008a5c:	fba2 2303 	umull	r2, r3, r2, r3
 8008a60:	095b      	lsrs	r3, r3, #5
 8008a62:	f003 0307 	and.w	r3, r3, #7
 8008a66:	617b      	str	r3, [r7, #20]
 8008a68:	e009      	b.n	8008a7e <USART_SetBaudRate+0xc6>

   }else
   {
	   //over sampling by 16
	   F_part = ((( F_part * 16)+ 50) / 100) & ((uint8_t)0x0F);
 8008a6a:	697b      	ldr	r3, [r7, #20]
 8008a6c:	011b      	lsls	r3, r3, #4
 8008a6e:	3332      	adds	r3, #50	; 0x32
 8008a70:	4a0b      	ldr	r2, [pc, #44]	; (8008aa0 <USART_SetBaudRate+0xe8>)
 8008a72:	fba2 2303 	umull	r2, r3, r2, r3
 8008a76:	095b      	lsrs	r3, r3, #5
 8008a78:	f003 030f 	and.w	r3, r3, #15
 8008a7c:	617b      	str	r3, [r7, #20]

   }

  //Place the fractional part in appropriate bit position . refer USART_BRR
  tempreg |= F_part;
 8008a7e:	693a      	ldr	r2, [r7, #16]
 8008a80:	697b      	ldr	r3, [r7, #20]
 8008a82:	4313      	orrs	r3, r2
 8008a84:	613b      	str	r3, [r7, #16]

  //copy the value of tempreg in to BRR register
  pUSARTx->BRR = tempreg;
 8008a86:	687b      	ldr	r3, [r7, #4]
 8008a88:	693a      	ldr	r2, [r7, #16]
 8008a8a:	609a      	str	r2, [r3, #8]
}
 8008a8c:	bf00      	nop
 8008a8e:	3720      	adds	r7, #32
 8008a90:	46bd      	mov	sp, r7
 8008a92:	bd80      	pop	{r7, pc}
 8008a94:	40011000 	.word	0x40011000
 8008a98:	40011400 	.word	0x40011400
 8008a9c:	40010000 	.word	0x40010000
 8008aa0:	51eb851f 	.word	0x51eb851f

08008aa4 <USART_Init>:
 *
 * @Note              -

 */
void USART_Init(USART_Handle_t *pUSARTHandle)
{
 8008aa4:	b580      	push	{r7, lr}
 8008aa6:	b084      	sub	sp, #16
 8008aa8:	af00      	add	r7, sp, #0
 8008aaa:	6078      	str	r0, [r7, #4]

	//Temporary variable
	uint32_t tempreg=0;
 8008aac:	2300      	movs	r3, #0
 8008aae:	60fb      	str	r3, [r7, #12]

/******************************** Configuration of CR1******************************************/

	//Implement the code to enable the Clock for given USART peripheral
	 USART_PeriClockControl(pUSARTHandle->pUSARTx,ENABLE);
 8008ab0:	687b      	ldr	r3, [r7, #4]
 8008ab2:	681b      	ldr	r3, [r3, #0]
 8008ab4:	2101      	movs	r1, #1
 8008ab6:	4618      	mov	r0, r3
 8008ab8:	f000 f880 	bl	8008bbc <USART_PeriClockControl>

	//Enable USART Tx and Rx engines according to the USART_Mode configuration item
	if ( pUSARTHandle->USART_Config.USART_Mode == USART_MODE_ONLY_RX)
 8008abc:	687b      	ldr	r3, [r7, #4]
 8008abe:	791b      	ldrb	r3, [r3, #4]
 8008ac0:	2b01      	cmp	r3, #1
 8008ac2:	d104      	bne.n	8008ace <USART_Init+0x2a>
	{
		//Implement the code to enable the Receiver bit field
		tempreg|= (1 << USART_CR1_RE);
 8008ac4:	68fb      	ldr	r3, [r7, #12]
 8008ac6:	f043 0304 	orr.w	r3, r3, #4
 8008aca:	60fb      	str	r3, [r7, #12]
 8008acc:	e010      	b.n	8008af0 <USART_Init+0x4c>
	}else if (pUSARTHandle->USART_Config.USART_Mode == USART_MODE_ONLY_TX)
 8008ace:	687b      	ldr	r3, [r7, #4]
 8008ad0:	791b      	ldrb	r3, [r3, #4]
 8008ad2:	2b00      	cmp	r3, #0
 8008ad4:	d104      	bne.n	8008ae0 <USART_Init+0x3c>
	{
		//Implement the code to enable the Transmitter bit field
		tempreg |= ( 1 << USART_CR1_TE );
 8008ad6:	68fb      	ldr	r3, [r7, #12]
 8008ad8:	f043 0308 	orr.w	r3, r3, #8
 8008adc:	60fb      	str	r3, [r7, #12]
 8008ade:	e007      	b.n	8008af0 <USART_Init+0x4c>

	}else if (pUSARTHandle->USART_Config.USART_Mode == USART_MODE_TXRX)
 8008ae0:	687b      	ldr	r3, [r7, #4]
 8008ae2:	791b      	ldrb	r3, [r3, #4]
 8008ae4:	2b02      	cmp	r3, #2
 8008ae6:	d103      	bne.n	8008af0 <USART_Init+0x4c>
	{
		//Implement the code to enable the both Transmitter and Receiver bit fields
		tempreg |= ( ( 1 << USART_CR1_RE) | ( 1 << USART_CR1_TE) );
 8008ae8:	68fb      	ldr	r3, [r7, #12]
 8008aea:	f043 030c 	orr.w	r3, r3, #12
 8008aee:	60fb      	str	r3, [r7, #12]
	}

    //Implement the code to configure the Word length configuration item
	tempreg |= pUSARTHandle->USART_Config.USART_WordLength << USART_CR1_M ;
 8008af0:	687b      	ldr	r3, [r7, #4]
 8008af2:	7b5b      	ldrb	r3, [r3, #13]
 8008af4:	031b      	lsls	r3, r3, #12
 8008af6:	461a      	mov	r2, r3
 8008af8:	68fb      	ldr	r3, [r7, #12]
 8008afa:	4313      	orrs	r3, r2
 8008afc:	60fb      	str	r3, [r7, #12]


    //Configuration of parity control bit fields
	if ( pUSARTHandle->USART_Config.USART_ParityControl == USART_PARITY_EN_EVEN)
 8008afe:	687b      	ldr	r3, [r7, #4]
 8008b00:	7b9b      	ldrb	r3, [r3, #14]
 8008b02:	2b01      	cmp	r3, #1
 8008b04:	d104      	bne.n	8008b10 <USART_Init+0x6c>
	{
		//Implement the code to enable the parity control
		tempreg |= ( 1 << USART_CR1_PCE);
 8008b06:	68fb      	ldr	r3, [r7, #12]
 8008b08:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 8008b0c:	60fb      	str	r3, [r7, #12]
 8008b0e:	e00b      	b.n	8008b28 <USART_Init+0x84>

		//Implement the code to enable EVEN parity
		//Not required because by default EVEN parity will be selected once you enable the parity control

	}else if (pUSARTHandle->USART_Config.USART_ParityControl == USART_PARITY_EN_ODD )
 8008b10:	687b      	ldr	r3, [r7, #4]
 8008b12:	7b9b      	ldrb	r3, [r3, #14]
 8008b14:	2b02      	cmp	r3, #2
 8008b16:	d107      	bne.n	8008b28 <USART_Init+0x84>
	{
		//Implement the code to enable the parity control
	    tempreg |= ( 1 << USART_CR1_PCE);
 8008b18:	68fb      	ldr	r3, [r7, #12]
 8008b1a:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 8008b1e:	60fb      	str	r3, [r7, #12]

	    //Implement the code to enable ODD parity
	    tempreg |= ( 1 << USART_CR1_PS);
 8008b20:	68fb      	ldr	r3, [r7, #12]
 8008b22:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 8008b26:	60fb      	str	r3, [r7, #12]

	}

   //Program the CR1 register
	pUSARTHandle->pUSARTx->CR1 = tempreg;
 8008b28:	687b      	ldr	r3, [r7, #4]
 8008b2a:	681b      	ldr	r3, [r3, #0]
 8008b2c:	68fa      	ldr	r2, [r7, #12]
 8008b2e:	60da      	str	r2, [r3, #12]

/******************************** Configuration of CR2******************************************/

	tempreg=0;
 8008b30:	2300      	movs	r3, #0
 8008b32:	60fb      	str	r3, [r7, #12]

	//Implement the code to configure the number of stop bits inserted during USART frame transmission
	tempreg |= pUSARTHandle->USART_Config.USART_NoOfStopBits << USART_CR2_STOP;
 8008b34:	687b      	ldr	r3, [r7, #4]
 8008b36:	7b1b      	ldrb	r3, [r3, #12]
 8008b38:	031b      	lsls	r3, r3, #12
 8008b3a:	461a      	mov	r2, r3
 8008b3c:	68fb      	ldr	r3, [r7, #12]
 8008b3e:	4313      	orrs	r3, r2
 8008b40:	60fb      	str	r3, [r7, #12]

	//Program the CR2 register
	pUSARTHandle->pUSARTx->CR2 = tempreg;
 8008b42:	687b      	ldr	r3, [r7, #4]
 8008b44:	681b      	ldr	r3, [r3, #0]
 8008b46:	68fa      	ldr	r2, [r7, #12]
 8008b48:	611a      	str	r2, [r3, #16]

/******************************** Configuration of CR3******************************************/

	tempreg=0;
 8008b4a:	2300      	movs	r3, #0
 8008b4c:	60fb      	str	r3, [r7, #12]

	//Configuration of USART hardware flow control
	if ( pUSARTHandle->USART_Config.USART_HWFlowControl == USART_HW_FLOW_CTRL_CTS)
 8008b4e:	687b      	ldr	r3, [r7, #4]
 8008b50:	7bdb      	ldrb	r3, [r3, #15]
 8008b52:	2b01      	cmp	r3, #1
 8008b54:	d104      	bne.n	8008b60 <USART_Init+0xbc>
	{
		//Implement the code to enable CTS flow control
		tempreg |= ( 1 << USART_CR3_CTSE);
 8008b56:	68fb      	ldr	r3, [r7, #12]
 8008b58:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 8008b5c:	60fb      	str	r3, [r7, #12]
 8008b5e:	e014      	b.n	8008b8a <USART_Init+0xe6>


	}else if (pUSARTHandle->USART_Config.USART_HWFlowControl == USART_HW_FLOW_CTRL_RTS)
 8008b60:	687b      	ldr	r3, [r7, #4]
 8008b62:	7bdb      	ldrb	r3, [r3, #15]
 8008b64:	2b02      	cmp	r3, #2
 8008b66:	d104      	bne.n	8008b72 <USART_Init+0xce>
	{
		//Implement the code to enable RTS flow control
		tempreg |= ( 1 << USART_CR3_RTSE);
 8008b68:	68fb      	ldr	r3, [r7, #12]
 8008b6a:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8008b6e:	60fb      	str	r3, [r7, #12]
 8008b70:	e00b      	b.n	8008b8a <USART_Init+0xe6>

	}else if (pUSARTHandle->USART_Config.USART_HWFlowControl == USART_HW_FLOW_CTRL_CTS_RTS)
 8008b72:	687b      	ldr	r3, [r7, #4]
 8008b74:	7bdb      	ldrb	r3, [r3, #15]
 8008b76:	2b03      	cmp	r3, #3
 8008b78:	d107      	bne.n	8008b8a <USART_Init+0xe6>
	{
		//Implement the code to enable both CTS and RTS Flow control
		tempreg |= ( 1 << USART_CR3_CTSE);
 8008b7a:	68fb      	ldr	r3, [r7, #12]
 8008b7c:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 8008b80:	60fb      	str	r3, [r7, #12]
		tempreg |= ( 1 << USART_CR3_RTSE);
 8008b82:	68fb      	ldr	r3, [r7, #12]
 8008b84:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8008b88:	60fb      	str	r3, [r7, #12]
	}


	pUSARTHandle->pUSARTx->CR3 = tempreg;
 8008b8a:	687b      	ldr	r3, [r7, #4]
 8008b8c:	681b      	ldr	r3, [r3, #0]
 8008b8e:	68fa      	ldr	r2, [r7, #12]
 8008b90:	615a      	str	r2, [r3, #20]

/******************************** Configuration of BRR(Baudrate register)******************************************/
	USART_SetBaudRate(pUSARTHandle->pUSARTx,pUSARTHandle->USART_Config.USART_Baud);
 8008b92:	687b      	ldr	r3, [r7, #4]
 8008b94:	681a      	ldr	r2, [r3, #0]
 8008b96:	687b      	ldr	r3, [r7, #4]
 8008b98:	689b      	ldr	r3, [r3, #8]
 8008b9a:	4619      	mov	r1, r3
 8008b9c:	4610      	mov	r0, r2
 8008b9e:	f7ff ff0b 	bl	80089b8 <USART_SetBaudRate>
	 pUSARTHandle->pUSARTx->CR1 |= (1 << USART_CR1_UE);
 8008ba2:	687b      	ldr	r3, [r7, #4]
 8008ba4:	681b      	ldr	r3, [r3, #0]
 8008ba6:	68da      	ldr	r2, [r3, #12]
 8008ba8:	687b      	ldr	r3, [r7, #4]
 8008baa:	681b      	ldr	r3, [r3, #0]
 8008bac:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
 8008bb0:	60da      	str	r2, [r3, #12]
}
 8008bb2:	bf00      	nop
 8008bb4:	3710      	adds	r7, #16
 8008bb6:	46bd      	mov	sp, r7
 8008bb8:	bd80      	pop	{r7, pc}
	...

08008bbc <USART_PeriClockControl>:
 *
 * @Note              -

 */
void USART_PeriClockControl(USART_type *pUSARTx, uint8_t EnorDi)
{
 8008bbc:	b480      	push	{r7}
 8008bbe:	b083      	sub	sp, #12
 8008bc0:	af00      	add	r7, sp, #0
 8008bc2:	6078      	str	r0, [r7, #4]
 8008bc4:	460b      	mov	r3, r1
 8008bc6:	70fb      	strb	r3, [r7, #3]
	if(EnorDi == ENABLE)
 8008bc8:	78fb      	ldrb	r3, [r7, #3]
 8008bca:	2b01      	cmp	r3, #1
 8008bcc:	d141      	bne.n	8008c52 <USART_PeriClockControl+0x96>
	{
		if(pUSARTx == USART1)
 8008bce:	687b      	ldr	r3, [r7, #4]
 8008bd0:	4a43      	ldr	r2, [pc, #268]	; (8008ce0 <USART_PeriClockControl+0x124>)
 8008bd2:	4293      	cmp	r3, r2
 8008bd4:	d106      	bne.n	8008be4 <USART_PeriClockControl+0x28>
		{
			USART1_CLKEN();
 8008bd6:	4b43      	ldr	r3, [pc, #268]	; (8008ce4 <USART_PeriClockControl+0x128>)
 8008bd8:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8008bda:	4a42      	ldr	r2, [pc, #264]	; (8008ce4 <USART_PeriClockControl+0x128>)
 8008bdc:	f043 0310 	orr.w	r3, r3, #16
 8008be0:	6453      	str	r3, [r2, #68]	; 0x44
		{
			USART6_CLKDI();
		}
	}

}
 8008be2:	e077      	b.n	8008cd4 <USART_PeriClockControl+0x118>
		}else if (pUSARTx == USART2)
 8008be4:	687b      	ldr	r3, [r7, #4]
 8008be6:	4a40      	ldr	r2, [pc, #256]	; (8008ce8 <USART_PeriClockControl+0x12c>)
 8008be8:	4293      	cmp	r3, r2
 8008bea:	d106      	bne.n	8008bfa <USART_PeriClockControl+0x3e>
			USART2_CLKEN();
 8008bec:	4b3d      	ldr	r3, [pc, #244]	; (8008ce4 <USART_PeriClockControl+0x128>)
 8008bee:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8008bf0:	4a3c      	ldr	r2, [pc, #240]	; (8008ce4 <USART_PeriClockControl+0x128>)
 8008bf2:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 8008bf6:	6413      	str	r3, [r2, #64]	; 0x40
}
 8008bf8:	e06c      	b.n	8008cd4 <USART_PeriClockControl+0x118>
		}else if (pUSARTx == USART3)
 8008bfa:	687b      	ldr	r3, [r7, #4]
 8008bfc:	4a3b      	ldr	r2, [pc, #236]	; (8008cec <USART_PeriClockControl+0x130>)
 8008bfe:	4293      	cmp	r3, r2
 8008c00:	d106      	bne.n	8008c10 <USART_PeriClockControl+0x54>
			USART3_CLKEN();
 8008c02:	4b38      	ldr	r3, [pc, #224]	; (8008ce4 <USART_PeriClockControl+0x128>)
 8008c04:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8008c06:	4a37      	ldr	r2, [pc, #220]	; (8008ce4 <USART_PeriClockControl+0x128>)
 8008c08:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
 8008c0c:	6413      	str	r3, [r2, #64]	; 0x40
}
 8008c0e:	e061      	b.n	8008cd4 <USART_PeriClockControl+0x118>
		else if (pUSARTx == UART4)
 8008c10:	687b      	ldr	r3, [r7, #4]
 8008c12:	4a37      	ldr	r2, [pc, #220]	; (8008cf0 <USART_PeriClockControl+0x134>)
 8008c14:	4293      	cmp	r3, r2
 8008c16:	d106      	bne.n	8008c26 <USART_PeriClockControl+0x6a>
			UART4_CLKEN();
 8008c18:	4b32      	ldr	r3, [pc, #200]	; (8008ce4 <USART_PeriClockControl+0x128>)
 8008c1a:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8008c1c:	4a31      	ldr	r2, [pc, #196]	; (8008ce4 <USART_PeriClockControl+0x128>)
 8008c1e:	f443 2300 	orr.w	r3, r3, #524288	; 0x80000
 8008c22:	6413      	str	r3, [r2, #64]	; 0x40
}
 8008c24:	e056      	b.n	8008cd4 <USART_PeriClockControl+0x118>
		else if (pUSARTx == UART5)
 8008c26:	687b      	ldr	r3, [r7, #4]
 8008c28:	4a32      	ldr	r2, [pc, #200]	; (8008cf4 <USART_PeriClockControl+0x138>)
 8008c2a:	4293      	cmp	r3, r2
 8008c2c:	d106      	bne.n	8008c3c <USART_PeriClockControl+0x80>
			UART5_CLKEN();
 8008c2e:	4b2d      	ldr	r3, [pc, #180]	; (8008ce4 <USART_PeriClockControl+0x128>)
 8008c30:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8008c32:	4a2c      	ldr	r2, [pc, #176]	; (8008ce4 <USART_PeriClockControl+0x128>)
 8008c34:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 8008c38:	6413      	str	r3, [r2, #64]	; 0x40
}
 8008c3a:	e04b      	b.n	8008cd4 <USART_PeriClockControl+0x118>
		else if (pUSARTx == USART6)
 8008c3c:	687b      	ldr	r3, [r7, #4]
 8008c3e:	4a2e      	ldr	r2, [pc, #184]	; (8008cf8 <USART_PeriClockControl+0x13c>)
 8008c40:	4293      	cmp	r3, r2
 8008c42:	d147      	bne.n	8008cd4 <USART_PeriClockControl+0x118>
			USART6_CLKEN();
 8008c44:	4b27      	ldr	r3, [pc, #156]	; (8008ce4 <USART_PeriClockControl+0x128>)
 8008c46:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8008c48:	4a26      	ldr	r2, [pc, #152]	; (8008ce4 <USART_PeriClockControl+0x128>)
 8008c4a:	f043 0320 	orr.w	r3, r3, #32
 8008c4e:	6453      	str	r3, [r2, #68]	; 0x44
}
 8008c50:	e040      	b.n	8008cd4 <USART_PeriClockControl+0x118>
		if(pUSARTx == USART1)
 8008c52:	687b      	ldr	r3, [r7, #4]
 8008c54:	4a22      	ldr	r2, [pc, #136]	; (8008ce0 <USART_PeriClockControl+0x124>)
 8008c56:	4293      	cmp	r3, r2
 8008c58:	d106      	bne.n	8008c68 <USART_PeriClockControl+0xac>
			USART1_CLKDI();
 8008c5a:	4b22      	ldr	r3, [pc, #136]	; (8008ce4 <USART_PeriClockControl+0x128>)
 8008c5c:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8008c5e:	4a21      	ldr	r2, [pc, #132]	; (8008ce4 <USART_PeriClockControl+0x128>)
 8008c60:	f023 0310 	bic.w	r3, r3, #16
 8008c64:	6453      	str	r3, [r2, #68]	; 0x44
}
 8008c66:	e035      	b.n	8008cd4 <USART_PeriClockControl+0x118>
		}else if (pUSARTx == USART2)
 8008c68:	687b      	ldr	r3, [r7, #4]
 8008c6a:	4a1f      	ldr	r2, [pc, #124]	; (8008ce8 <USART_PeriClockControl+0x12c>)
 8008c6c:	4293      	cmp	r3, r2
 8008c6e:	d106      	bne.n	8008c7e <USART_PeriClockControl+0xc2>
			USART2_CLKDI();
 8008c70:	4b1c      	ldr	r3, [pc, #112]	; (8008ce4 <USART_PeriClockControl+0x128>)
 8008c72:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8008c74:	4a1b      	ldr	r2, [pc, #108]	; (8008ce4 <USART_PeriClockControl+0x128>)
 8008c76:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
 8008c7a:	6413      	str	r3, [r2, #64]	; 0x40
}
 8008c7c:	e02a      	b.n	8008cd4 <USART_PeriClockControl+0x118>
		}else if (pUSARTx == USART3)
 8008c7e:	687b      	ldr	r3, [r7, #4]
 8008c80:	4a1a      	ldr	r2, [pc, #104]	; (8008cec <USART_PeriClockControl+0x130>)
 8008c82:	4293      	cmp	r3, r2
 8008c84:	d106      	bne.n	8008c94 <USART_PeriClockControl+0xd8>
			USART3_CLKDI();
 8008c86:	4b17      	ldr	r3, [pc, #92]	; (8008ce4 <USART_PeriClockControl+0x128>)
 8008c88:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8008c8a:	4a16      	ldr	r2, [pc, #88]	; (8008ce4 <USART_PeriClockControl+0x128>)
 8008c8c:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
 8008c90:	6413      	str	r3, [r2, #64]	; 0x40
}
 8008c92:	e01f      	b.n	8008cd4 <USART_PeriClockControl+0x118>
		else if (pUSARTx == UART4)
 8008c94:	687b      	ldr	r3, [r7, #4]
 8008c96:	4a16      	ldr	r2, [pc, #88]	; (8008cf0 <USART_PeriClockControl+0x134>)
 8008c98:	4293      	cmp	r3, r2
 8008c9a:	d106      	bne.n	8008caa <USART_PeriClockControl+0xee>
			UART4_CLKDI();
 8008c9c:	4b11      	ldr	r3, [pc, #68]	; (8008ce4 <USART_PeriClockControl+0x128>)
 8008c9e:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8008ca0:	4a10      	ldr	r2, [pc, #64]	; (8008ce4 <USART_PeriClockControl+0x128>)
 8008ca2:	f423 2300 	bic.w	r3, r3, #524288	; 0x80000
 8008ca6:	6413      	str	r3, [r2, #64]	; 0x40
}
 8008ca8:	e014      	b.n	8008cd4 <USART_PeriClockControl+0x118>
		else if (pUSARTx == UART5)
 8008caa:	687b      	ldr	r3, [r7, #4]
 8008cac:	4a11      	ldr	r2, [pc, #68]	; (8008cf4 <USART_PeriClockControl+0x138>)
 8008cae:	4293      	cmp	r3, r2
 8008cb0:	d106      	bne.n	8008cc0 <USART_PeriClockControl+0x104>
			UART5_CLKDI();
 8008cb2:	4b0c      	ldr	r3, [pc, #48]	; (8008ce4 <USART_PeriClockControl+0x128>)
 8008cb4:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8008cb6:	4a0b      	ldr	r2, [pc, #44]	; (8008ce4 <USART_PeriClockControl+0x128>)
 8008cb8:	f423 1380 	bic.w	r3, r3, #1048576	; 0x100000
 8008cbc:	6413      	str	r3, [r2, #64]	; 0x40
}
 8008cbe:	e009      	b.n	8008cd4 <USART_PeriClockControl+0x118>
		else if (pUSARTx == USART6)
 8008cc0:	687b      	ldr	r3, [r7, #4]
 8008cc2:	4a0d      	ldr	r2, [pc, #52]	; (8008cf8 <USART_PeriClockControl+0x13c>)
 8008cc4:	4293      	cmp	r3, r2
 8008cc6:	d105      	bne.n	8008cd4 <USART_PeriClockControl+0x118>
			USART6_CLKDI();
 8008cc8:	4b06      	ldr	r3, [pc, #24]	; (8008ce4 <USART_PeriClockControl+0x128>)
 8008cca:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8008ccc:	4a05      	ldr	r2, [pc, #20]	; (8008ce4 <USART_PeriClockControl+0x128>)
 8008cce:	f023 0320 	bic.w	r3, r3, #32
 8008cd2:	6453      	str	r3, [r2, #68]	; 0x44
}
 8008cd4:	bf00      	nop
 8008cd6:	370c      	adds	r7, #12
 8008cd8:	46bd      	mov	sp, r7
 8008cda:	bc80      	pop	{r7}
 8008cdc:	4770      	bx	lr
 8008cde:	bf00      	nop
 8008ce0:	40011000 	.word	0x40011000
 8008ce4:	40023800 	.word	0x40023800
 8008ce8:	40004400 	.word	0x40004400
 8008cec:	40004800 	.word	0x40004800
 8008cf0:	40004c00 	.word	0x40004c00
 8008cf4:	40005000 	.word	0x40005000
 8008cf8:	40011400 	.word	0x40011400

08008cfc <USART_GetFlagStatus>:
 *
 * @Note              -

 */
uint8_t USART_GetFlagStatus(USART_type *pUSARTx, uint8_t StatusFlagName)
{
 8008cfc:	b480      	push	{r7}
 8008cfe:	b083      	sub	sp, #12
 8008d00:	af00      	add	r7, sp, #0
 8008d02:	6078      	str	r0, [r7, #4]
 8008d04:	460b      	mov	r3, r1
 8008d06:	70fb      	strb	r3, [r7, #3]
    if(pUSARTx->SR & StatusFlagName)
 8008d08:	687b      	ldr	r3, [r7, #4]
 8008d0a:	681a      	ldr	r2, [r3, #0]
 8008d0c:	78fb      	ldrb	r3, [r7, #3]
 8008d0e:	4013      	ands	r3, r2
 8008d10:	2b00      	cmp	r3, #0
 8008d12:	d001      	beq.n	8008d18 <USART_GetFlagStatus+0x1c>
    {
    	return SET;
 8008d14:	2301      	movs	r3, #1
 8008d16:	e000      	b.n	8008d1a <USART_GetFlagStatus+0x1e>
    }

   return RESET;
 8008d18:	2300      	movs	r3, #0
}
 8008d1a:	4618      	mov	r0, r3
 8008d1c:	370c      	adds	r7, #12
 8008d1e:	46bd      	mov	sp, r7
 8008d20:	bc80      	pop	{r7}
 8008d22:	4770      	bx	lr

08008d24 <USART_SendData>:
 *
 * @Note              - Resolve all the TODOs

 */
void USART_SendData(USART_Handle_t *pUSARTHandle, uint8_t *pTxBuffer, uint32_t Len)
{
 8008d24:	b580      	push	{r7, lr}
 8008d26:	b086      	sub	sp, #24
 8008d28:	af00      	add	r7, sp, #0
 8008d2a:	60f8      	str	r0, [r7, #12]
 8008d2c:	60b9      	str	r1, [r7, #8]
 8008d2e:	607a      	str	r2, [r7, #4]

	uint16_t *pdata;
   //Loop over until "Len" number of bytes are transferred
	for(uint32_t i = 0 ; i < Len; i++)
 8008d30:	2300      	movs	r3, #0
 8008d32:	617b      	str	r3, [r7, #20]
 8008d34:	e031      	b.n	8008d9a <USART_SendData+0x76>
	{
		//Implement the code to wait until TXE flag is set in the SR
		while(! USART_GetFlagStatus(pUSARTHandle->pUSARTx,USART_FLAG_TXE));
 8008d36:	bf00      	nop
 8008d38:	68fb      	ldr	r3, [r7, #12]
 8008d3a:	681b      	ldr	r3, [r3, #0]
 8008d3c:	2180      	movs	r1, #128	; 0x80
 8008d3e:	4618      	mov	r0, r3
 8008d40:	f7ff ffdc 	bl	8008cfc <USART_GetFlagStatus>
 8008d44:	4603      	mov	r3, r0
 8008d46:	2b00      	cmp	r3, #0
 8008d48:	d0f6      	beq.n	8008d38 <USART_SendData+0x14>

		//Check the USART_WordLength item for 9BIT or 8BIT in a frame
		if(pUSARTHandle->USART_Config.USART_WordLength == USART_WORDLEN_9BITS)
 8008d4a:	68fb      	ldr	r3, [r7, #12]
 8008d4c:	7b5b      	ldrb	r3, [r3, #13]
 8008d4e:	2b01      	cmp	r3, #1
 8008d50:	d118      	bne.n	8008d84 <USART_SendData+0x60>
		{
			//if 9BIT load the DR with 2bytes masking  the bits other than first 9 bits
			pdata = (uint16_t*) pTxBuffer;
 8008d52:	68bb      	ldr	r3, [r7, #8]
 8008d54:	613b      	str	r3, [r7, #16]
			pUSARTHandle->pUSARTx->DR = (*pdata & (uint16_t)0x01FF);
 8008d56:	693b      	ldr	r3, [r7, #16]
 8008d58:	881b      	ldrh	r3, [r3, #0]
 8008d5a:	461a      	mov	r2, r3
 8008d5c:	68fb      	ldr	r3, [r7, #12]
 8008d5e:	681b      	ldr	r3, [r3, #0]
 8008d60:	f3c2 0208 	ubfx	r2, r2, #0, #9
 8008d64:	605a      	str	r2, [r3, #4]

			//check for USART_ParityControl
			if(pUSARTHandle->USART_Config.USART_ParityControl == USART_PARITY_DISABLE)
 8008d66:	68fb      	ldr	r3, [r7, #12]
 8008d68:	7b9b      	ldrb	r3, [r3, #14]
 8008d6a:	2b00      	cmp	r3, #0
 8008d6c:	d106      	bne.n	8008d7c <USART_SendData+0x58>
			{
				//No parity is used in this transfer , so 9bits of user data will be sent
				//Implement the code to increment pTxBuffer twice
				pTxBuffer++;
 8008d6e:	68bb      	ldr	r3, [r7, #8]
 8008d70:	3301      	adds	r3, #1
 8008d72:	60bb      	str	r3, [r7, #8]
				pTxBuffer++;
 8008d74:	68bb      	ldr	r3, [r7, #8]
 8008d76:	3301      	adds	r3, #1
 8008d78:	60bb      	str	r3, [r7, #8]
 8008d7a:	e00b      	b.n	8008d94 <USART_SendData+0x70>
			}
			else
			{
				//Parity bit is used in this transfer . so 8bits of user data will be sent
				//The 9th bit will be replaced by parity bit by the hardware
				pTxBuffer++;
 8008d7c:	68bb      	ldr	r3, [r7, #8]
 8008d7e:	3301      	adds	r3, #1
 8008d80:	60bb      	str	r3, [r7, #8]
 8008d82:	e007      	b.n	8008d94 <USART_SendData+0x70>
			}
		}
		else
		{
			//This is 8bit data transfer
			pUSARTHandle->pUSARTx->DR = (*pTxBuffer  & (uint8_t)0xFF);
 8008d84:	68bb      	ldr	r3, [r7, #8]
 8008d86:	781a      	ldrb	r2, [r3, #0]
 8008d88:	68fb      	ldr	r3, [r7, #12]
 8008d8a:	681b      	ldr	r3, [r3, #0]
 8008d8c:	605a      	str	r2, [r3, #4]

			//Implement the code to increment the buffer address
			pTxBuffer++;
 8008d8e:	68bb      	ldr	r3, [r7, #8]
 8008d90:	3301      	adds	r3, #1
 8008d92:	60bb      	str	r3, [r7, #8]
	for(uint32_t i = 0 ; i < Len; i++)
 8008d94:	697b      	ldr	r3, [r7, #20]
 8008d96:	3301      	adds	r3, #1
 8008d98:	617b      	str	r3, [r7, #20]
 8008d9a:	697a      	ldr	r2, [r7, #20]
 8008d9c:	687b      	ldr	r3, [r7, #4]
 8008d9e:	429a      	cmp	r2, r3
 8008da0:	d3c9      	bcc.n	8008d36 <USART_SendData+0x12>
		}
	}

	//Implement the code to wait till TC flag is set in the SR
	while( ! USART_GetFlagStatus(pUSARTHandle->pUSARTx,USART_FLAG_TC));
 8008da2:	bf00      	nop
 8008da4:	68fb      	ldr	r3, [r7, #12]
 8008da6:	681b      	ldr	r3, [r3, #0]
 8008da8:	2140      	movs	r1, #64	; 0x40
 8008daa:	4618      	mov	r0, r3
 8008dac:	f7ff ffa6 	bl	8008cfc <USART_GetFlagStatus>
 8008db0:	4603      	mov	r3, r0
 8008db2:	2b00      	cmp	r3, #0
 8008db4:	d0f6      	beq.n	8008da4 <USART_SendData+0x80>
}
 8008db6:	bf00      	nop
 8008db8:	bf00      	nop
 8008dba:	3718      	adds	r7, #24
 8008dbc:	46bd      	mov	sp, r7
 8008dbe:	bd80      	pop	{r7, pc}

08008dc0 <main>:

RingBuff Ring;
USART_Handle_t USART;
GPIO_Handle_t Button;

int main(void){
 8008dc0:	b580      	push	{r7, lr}
 8008dc2:	af00      	add	r7, sp, #0
	*SCB_VTOR = FLASH_BASEADRR | BOOTLOADER_SIZE ; //offset vector table
 8008dc4:	4b14      	ldr	r3, [pc, #80]	; (8008e18 <main+0x58>)
 8008dc6:	4a15      	ldr	r2, [pc, #84]	; (8008e1c <main+0x5c>)
 8008dc8:	601a      	str	r2, [r3, #0]

	Button.pGPIOx = GPIOC;
 8008dca:	4b15      	ldr	r3, [pc, #84]	; (8008e20 <main+0x60>)
 8008dcc:	4a15      	ldr	r2, [pc, #84]	; (8008e24 <main+0x64>)
 8008dce:	601a      	str	r2, [r3, #0]
	GPIO_ButtonInitIT(Button.pGPIOx, GPIO_PIN_NO_13);
 8008dd0:	4b13      	ldr	r3, [pc, #76]	; (8008e20 <main+0x60>)
 8008dd2:	681b      	ldr	r3, [r3, #0]
 8008dd4:	210d      	movs	r1, #13
 8008dd6:	4618      	mov	r0, r3
 8008dd8:	f7ff fa41 	bl	800825e <GPIO_ButtonInitIT>

	USART_GPIOInit(GPIOA, GPIO_PIN_NO_2, 7); //TX
 8008ddc:	2207      	movs	r2, #7
 8008dde:	2102      	movs	r1, #2
 8008de0:	4811      	ldr	r0, [pc, #68]	; (8008e28 <main+0x68>)
 8008de2:	f7ff fa0f 	bl	8008204 <USART_GPIOInit>
	USART_GPIOInit(GPIOA, GPIO_PIN_NO_3, 7); //RX
 8008de6:	2207      	movs	r2, #7
 8008de8:	2103      	movs	r1, #3
 8008dea:	480f      	ldr	r0, [pc, #60]	; (8008e28 <main+0x68>)
 8008dec:	f7ff fa0a 	bl	8008204 <USART_GPIOInit>

	USART.pUSARTx = USART2;
 8008df0:	4b0e      	ldr	r3, [pc, #56]	; (8008e2c <main+0x6c>)
 8008df2:	4a0f      	ldr	r2, [pc, #60]	; (8008e30 <main+0x70>)
 8008df4:	601a      	str	r2, [r3, #0]
	USART_setup(&USART);
 8008df6:	480d      	ldr	r0, [pc, #52]	; (8008e2c <main+0x6c>)
 8008df8:	f000 f820 	bl	8008e3c <USART_setup>

	Ring.read_index = 0;
 8008dfc:	4b0d      	ldr	r3, [pc, #52]	; (8008e34 <main+0x74>)
 8008dfe:	2200      	movs	r2, #0
 8008e00:	f883 2064 	strb.w	r2, [r3, #100]	; 0x64
	Ring.write_index = 0;
 8008e04:	4b0b      	ldr	r3, [pc, #44]	; (8008e34 <main+0x74>)
 8008e06:	2200      	movs	r2, #0
 8008e08:	f883 2065 	strb.w	r2, [r3, #101]	; 0x65

	USART_SendData(&USART, (uint8_t *)hello, sizeof(hello));
 8008e0c:	221e      	movs	r2, #30
 8008e0e:	490a      	ldr	r1, [pc, #40]	; (8008e38 <main+0x78>)
 8008e10:	4806      	ldr	r0, [pc, #24]	; (8008e2c <main+0x6c>)
 8008e12:	f7ff ff87 	bl	8008d24 <USART_SendData>
	while(1){
 8008e16:	e7fe      	b.n	8008e16 <main+0x56>
 8008e18:	e000ed08 	.word	0xe000ed08
 8008e1c:	08008000 	.word	0x08008000
 8008e20:	200000d0 	.word	0x200000d0
 8008e24:	40020800 	.word	0x40020800
 8008e28:	40020000 	.word	0x40020000
 8008e2c:	200000ac 	.word	0x200000ac
 8008e30:	40004400 	.word	0x40004400
 8008e34:	20000044 	.word	0x20000044
 8008e38:	20000008 	.word	0x20000008

08008e3c <USART_setup>:
	}
}



static void USART_setup(USART_Handle_t *pUSARTHandle){
 8008e3c:	b580      	push	{r7, lr}
 8008e3e:	b082      	sub	sp, #8
 8008e40:	af00      	add	r7, sp, #0
 8008e42:	6078      	str	r0, [r7, #4]
	pUSARTHandle->USART_Config.USART_Baud =  USART_STD_BAUD_115200;
 8008e44:	687b      	ldr	r3, [r7, #4]
 8008e46:	f44f 32e1 	mov.w	r2, #115200	; 0x1c200
 8008e4a:	609a      	str	r2, [r3, #8]
	pUSARTHandle->USART_Config.USART_Mode =  USART_MODE_TXRX;
 8008e4c:	687b      	ldr	r3, [r7, #4]
 8008e4e:	2202      	movs	r2, #2
 8008e50:	711a      	strb	r2, [r3, #4]
	pUSARTHandle->USART_Config.USART_NoOfStopBits = USART_STOPBITS_1;
 8008e52:	687b      	ldr	r3, [r7, #4]
 8008e54:	2200      	movs	r2, #0
 8008e56:	731a      	strb	r2, [r3, #12]
	pUSARTHandle->USART_Config.USART_ParityControl = USART_PARITY_DISABLE;
 8008e58:	687b      	ldr	r3, [r7, #4]
 8008e5a:	2200      	movs	r2, #0
 8008e5c:	739a      	strb	r2, [r3, #14]
	pUSARTHandle->USART_Config.USART_WordLength = USART_WORDLEN_8BITS;
 8008e5e:	687b      	ldr	r3, [r7, #4]
 8008e60:	2200      	movs	r2, #0
 8008e62:	735a      	strb	r2, [r3, #13]
	USART_PeriClockControl(pUSARTHandle->pUSARTx, ENABLE);
 8008e64:	687b      	ldr	r3, [r7, #4]
 8008e66:	681b      	ldr	r3, [r3, #0]
 8008e68:	2101      	movs	r1, #1
 8008e6a:	4618      	mov	r0, r3
 8008e6c:	f7ff fea6 	bl	8008bbc <USART_PeriClockControl>
	USART_Init(pUSARTHandle);
 8008e70:	6878      	ldr	r0, [r7, #4]
 8008e72:	f7ff fe17 	bl	8008aa4 <USART_Init>
	*ISER1 |= (1 << (IRQ_USART2 % 32));//enable USART2 NVIC line
 8008e76:	4b09      	ldr	r3, [pc, #36]	; (8008e9c <USART_setup+0x60>)
 8008e78:	681b      	ldr	r3, [r3, #0]
 8008e7a:	4a08      	ldr	r2, [pc, #32]	; (8008e9c <USART_setup+0x60>)
 8008e7c:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8008e80:	6013      	str	r3, [r2, #0]
	pUSARTHandle->pUSARTx->CR1 |= (1U << USART_CR1_RXNEIE);//enable RXNE interrupt
 8008e82:	687b      	ldr	r3, [r7, #4]
 8008e84:	681b      	ldr	r3, [r3, #0]
 8008e86:	68da      	ldr	r2, [r3, #12]
 8008e88:	687b      	ldr	r3, [r7, #4]
 8008e8a:	681b      	ldr	r3, [r3, #0]
 8008e8c:	f042 0220 	orr.w	r2, r2, #32
 8008e90:	60da      	str	r2, [r3, #12]
}
 8008e92:	bf00      	nop
 8008e94:	3708      	adds	r7, #8
 8008e96:	46bd      	mov	sp, r7
 8008e98:	bd80      	pop	{r7, pc}
 8008e9a:	bf00      	nop
 8008e9c:	e000e104 	.word	0xe000e104

08008ea0 <EXTI15_10_IRQHandler>:


void EXTI15_10_IRQHandler(void){
 8008ea0:	b580      	push	{r7, lr}
 8008ea2:	af00      	add	r7, sp, #0
	if(! GPIO_ReadFromInputPin(Button.pGPIOx, Button.GPIO_PinConfig.GPIO_PinNumber)){
 8008ea4:	4b1a      	ldr	r3, [pc, #104]	; (8008f10 <EXTI15_10_IRQHandler+0x70>)
 8008ea6:	681b      	ldr	r3, [r3, #0]
 8008ea8:	4a19      	ldr	r2, [pc, #100]	; (8008f10 <EXTI15_10_IRQHandler+0x70>)
 8008eaa:	7912      	ldrb	r2, [r2, #4]
 8008eac:	4611      	mov	r1, r2
 8008eae:	4618      	mov	r0, r3
 8008eb0:	f7ff fc32 	bl	8008718 <GPIO_ReadFromInputPin>
 8008eb4:	4603      	mov	r3, r0
 8008eb6:	2b00      	cmp	r3, #0
 8008eb8:	d128      	bne.n	8008f0c <EXTI15_10_IRQHandler+0x6c>
		EXTI ->PR |= (1 << Button.GPIO_PinConfig.GPIO_PinNumber); /*clear the pending bit in EXTI*/
 8008eba:	4b16      	ldr	r3, [pc, #88]	; (8008f14 <EXTI15_10_IRQHandler+0x74>)
 8008ebc:	695b      	ldr	r3, [r3, #20]
 8008ebe:	4a14      	ldr	r2, [pc, #80]	; (8008f10 <EXTI15_10_IRQHandler+0x70>)
 8008ec0:	7912      	ldrb	r2, [r2, #4]
 8008ec2:	4611      	mov	r1, r2
 8008ec4:	2201      	movs	r2, #1
 8008ec6:	408a      	lsls	r2, r1
 8008ec8:	4611      	mov	r1, r2
 8008eca:	4a12      	ldr	r2, [pc, #72]	; (8008f14 <EXTI15_10_IRQHandler+0x74>)
 8008ecc:	430b      	orrs	r3, r1
 8008ece:	6153      	str	r3, [r2, #20]
		if(Ring.write_index == Ring.read_index){
 8008ed0:	4b11      	ldr	r3, [pc, #68]	; (8008f18 <EXTI15_10_IRQHandler+0x78>)
 8008ed2:	f893 2065 	ldrb.w	r2, [r3, #101]	; 0x65
 8008ed6:	4b10      	ldr	r3, [pc, #64]	; (8008f18 <EXTI15_10_IRQHandler+0x78>)
 8008ed8:	f893 3064 	ldrb.w	r3, [r3, #100]	; 0x64
 8008edc:	429a      	cmp	r2, r3
 8008ede:	d015      	beq.n	8008f0c <EXTI15_10_IRQHandler+0x6c>
			;
		}else{
			USART_SendData(&USART, (uint8_t *)(&Ring.buffer[Ring.read_index]), 1);
 8008ee0:	4b0d      	ldr	r3, [pc, #52]	; (8008f18 <EXTI15_10_IRQHandler+0x78>)
 8008ee2:	f893 3064 	ldrb.w	r3, [r3, #100]	; 0x64
 8008ee6:	461a      	mov	r2, r3
 8008ee8:	4b0b      	ldr	r3, [pc, #44]	; (8008f18 <EXTI15_10_IRQHandler+0x78>)
 8008eea:	4413      	add	r3, r2
 8008eec:	2201      	movs	r2, #1
 8008eee:	4619      	mov	r1, r3
 8008ef0:	480a      	ldr	r0, [pc, #40]	; (8008f1c <EXTI15_10_IRQHandler+0x7c>)
 8008ef2:	f7ff ff17 	bl	8008d24 <USART_SendData>
			Ring.read_index = (Ring.read_index + 1) & 0x7FU;
 8008ef6:	4b08      	ldr	r3, [pc, #32]	; (8008f18 <EXTI15_10_IRQHandler+0x78>)
 8008ef8:	f893 3064 	ldrb.w	r3, [r3, #100]	; 0x64
 8008efc:	3301      	adds	r3, #1
 8008efe:	b2db      	uxtb	r3, r3
 8008f00:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8008f04:	b2da      	uxtb	r2, r3
 8008f06:	4b04      	ldr	r3, [pc, #16]	; (8008f18 <EXTI15_10_IRQHandler+0x78>)
 8008f08:	f883 2064 	strb.w	r2, [r3, #100]	; 0x64
		}
	}
}
 8008f0c:	bf00      	nop
 8008f0e:	bd80      	pop	{r7, pc}
 8008f10:	200000d0 	.word	0x200000d0
 8008f14:	40013c00 	.word	0x40013c00
 8008f18:	20000044 	.word	0x20000044
 8008f1c:	200000ac 	.word	0x200000ac

08008f20 <USART2_IRQHandler>:

void USART2_IRQHandler(void){
 8008f20:	b480      	push	{r7}
 8008f22:	af00      	add	r7, sp, #0
	//if(Ring.write_index == Ring.read_index && (Ring.write_index != 0)){
		//;
	//}else{
		Ring.buffer[Ring.write_index] = (uint8_t)USART.pUSARTx->DR;
 8008f24:	4b0c      	ldr	r3, [pc, #48]	; (8008f58 <USART2_IRQHandler+0x38>)
 8008f26:	681b      	ldr	r3, [r3, #0]
 8008f28:	6859      	ldr	r1, [r3, #4]
 8008f2a:	4b0c      	ldr	r3, [pc, #48]	; (8008f5c <USART2_IRQHandler+0x3c>)
 8008f2c:	f893 3065 	ldrb.w	r3, [r3, #101]	; 0x65
 8008f30:	461a      	mov	r2, r3
 8008f32:	b2c9      	uxtb	r1, r1
 8008f34:	4b09      	ldr	r3, [pc, #36]	; (8008f5c <USART2_IRQHandler+0x3c>)
 8008f36:	5499      	strb	r1, [r3, r2]
		Ring.write_index = (1 + Ring.write_index)& 0x7FU;
 8008f38:	4b08      	ldr	r3, [pc, #32]	; (8008f5c <USART2_IRQHandler+0x3c>)
 8008f3a:	f893 3065 	ldrb.w	r3, [r3, #101]	; 0x65
 8008f3e:	3301      	adds	r3, #1
 8008f40:	b2db      	uxtb	r3, r3
 8008f42:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8008f46:	b2da      	uxtb	r2, r3
 8008f48:	4b04      	ldr	r3, [pc, #16]	; (8008f5c <USART2_IRQHandler+0x3c>)
 8008f4a:	f883 2065 	strb.w	r2, [r3, #101]	; 0x65
	//}
}
 8008f4e:	bf00      	nop
 8008f50:	46bd      	mov	sp, r7
 8008f52:	bc80      	pop	{r7}
 8008f54:	4770      	bx	lr
 8008f56:	bf00      	nop
 8008f58:	200000ac 	.word	0x200000ac
 8008f5c:	20000044 	.word	0x20000044

08008f60 <Reset_Handler>:

  .section .text.Reset_Handler
  .weak Reset_Handler
  .type Reset_Handler, %function
Reset_Handler:
  ldr   r0, =_estack
 8008f60:	480d      	ldr	r0, [pc, #52]	; (8008f98 <LoopForever+0x2>)
  mov   sp, r0          /* set stack pointer */
 8008f62:	4685      	mov	sp, r0
/* Call the clock system initialization function.*/
  bl  SystemInit
 8008f64:	f3af 8000 	nop.w

/* Copy the data segment initializers from flash to SRAM */
  ldr r0, =_sdata
 8008f68:	480c      	ldr	r0, [pc, #48]	; (8008f9c <LoopForever+0x6>)
  ldr r1, =_edata
 8008f6a:	490d      	ldr	r1, [pc, #52]	; (8008fa0 <LoopForever+0xa>)
  ldr r2, =_sidata
 8008f6c:	4a0d      	ldr	r2, [pc, #52]	; (8008fa4 <LoopForever+0xe>)
  movs r3, #0
 8008f6e:	2300      	movs	r3, #0
  b LoopCopyDataInit
 8008f70:	e002      	b.n	8008f78 <LoopCopyDataInit>

08008f72 <CopyDataInit>:

CopyDataInit:
  ldr r4, [r2, r3]
 8008f72:	58d4      	ldr	r4, [r2, r3]
  str r4, [r0, r3]
 8008f74:	50c4      	str	r4, [r0, r3]
  adds r3, r3, #4
 8008f76:	3304      	adds	r3, #4

08008f78 <LoopCopyDataInit>:

LoopCopyDataInit:
  adds r4, r0, r3
 8008f78:	18c4      	adds	r4, r0, r3
  cmp r4, r1
 8008f7a:	428c      	cmp	r4, r1
  bcc CopyDataInit
 8008f7c:	d3f9      	bcc.n	8008f72 <CopyDataInit>

/* Zero fill the bss segment. */
  ldr r2, =_sbss
 8008f7e:	4a0a      	ldr	r2, [pc, #40]	; (8008fa8 <LoopForever+0x12>)
  ldr r4, =_ebss
 8008f80:	4c0a      	ldr	r4, [pc, #40]	; (8008fac <LoopForever+0x16>)
  movs r3, #0
 8008f82:	2300      	movs	r3, #0
  b LoopFillZerobss
 8008f84:	e001      	b.n	8008f8a <LoopFillZerobss>

08008f86 <FillZerobss>:

FillZerobss:
  str  r3, [r2]
 8008f86:	6013      	str	r3, [r2, #0]
  adds r2, r2, #4
 8008f88:	3204      	adds	r2, #4

08008f8a <LoopFillZerobss>:

LoopFillZerobss:
  cmp r2, r4
 8008f8a:	42a2      	cmp	r2, r4
  bcc FillZerobss
 8008f8c:	d3fb      	bcc.n	8008f86 <FillZerobss>

/* Call static constructors */
  bl __libc_init_array
 8008f8e:	f000 f811 	bl	8008fb4 <__libc_init_array>
/* Call the application's entry point.*/
  bl main
 8008f92:	f7ff ff15 	bl	8008dc0 <main>

08008f96 <LoopForever>:

LoopForever:
  b LoopForever
 8008f96:	e7fe      	b.n	8008f96 <LoopForever>
  ldr   r0, =_estack
 8008f98:	20020000 	.word	0x20020000
  ldr r0, =_sdata
 8008f9c:	20000000 	.word	0x20000000
  ldr r1, =_edata
 8008fa0:	20000028 	.word	0x20000028
  ldr r2, =_sidata
 8008fa4:	0800901c 	.word	0x0800901c
  ldr r2, =_sbss
 8008fa8:	20000028 	.word	0x20000028
  ldr r4, =_ebss
 8008fac:	200000dc 	.word	0x200000dc

08008fb0 <ADC_IRQHandler>:
 * @retval : None
*/
  .section .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b Infinite_Loop
 8008fb0:	e7fe      	b.n	8008fb0 <ADC_IRQHandler>
	...

08008fb4 <__libc_init_array>:
 8008fb4:	b570      	push	{r4, r5, r6, lr}
 8008fb6:	4d0d      	ldr	r5, [pc, #52]	; (8008fec <__libc_init_array+0x38>)
 8008fb8:	4c0d      	ldr	r4, [pc, #52]	; (8008ff0 <__libc_init_array+0x3c>)
 8008fba:	1b64      	subs	r4, r4, r5
 8008fbc:	10a4      	asrs	r4, r4, #2
 8008fbe:	2600      	movs	r6, #0
 8008fc0:	42a6      	cmp	r6, r4
 8008fc2:	d109      	bne.n	8008fd8 <__libc_init_array+0x24>
 8008fc4:	4d0b      	ldr	r5, [pc, #44]	; (8008ff4 <__libc_init_array+0x40>)
 8008fc6:	4c0c      	ldr	r4, [pc, #48]	; (8008ff8 <__libc_init_array+0x44>)
 8008fc8:	f000 f818 	bl	8008ffc <_init>
 8008fcc:	1b64      	subs	r4, r4, r5
 8008fce:	10a4      	asrs	r4, r4, #2
 8008fd0:	2600      	movs	r6, #0
 8008fd2:	42a6      	cmp	r6, r4
 8008fd4:	d105      	bne.n	8008fe2 <__libc_init_array+0x2e>
 8008fd6:	bd70      	pop	{r4, r5, r6, pc}
 8008fd8:	f855 3b04 	ldr.w	r3, [r5], #4
 8008fdc:	4798      	blx	r3
 8008fde:	3601      	adds	r6, #1
 8008fe0:	e7ee      	b.n	8008fc0 <__libc_init_array+0xc>
 8008fe2:	f855 3b04 	ldr.w	r3, [r5], #4
 8008fe6:	4798      	blx	r3
 8008fe8:	3601      	adds	r6, #1
 8008fea:	e7f2      	b.n	8008fd2 <__libc_init_array+0x1e>
 8008fec:	08009014 	.word	0x08009014
 8008ff0:	08009014 	.word	0x08009014
 8008ff4:	08009014 	.word	0x08009014
 8008ff8:	08009018 	.word	0x08009018

08008ffc <_init>:
 8008ffc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8008ffe:	bf00      	nop
 8009000:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8009002:	bc08      	pop	{r3}
 8009004:	469e      	mov	lr, r3
 8009006:	4770      	bx	lr

08009008 <_fini>:
 8009008:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800900a:	bf00      	nop
 800900c:	bcf8      	pop	{r3, r4, r5, r6, r7}
 800900e:	bc08      	pop	{r3}
 8009010:	469e      	mov	lr, r3
 8009012:	4770      	bx	lr
