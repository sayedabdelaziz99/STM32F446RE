/*
 * I2C_Driver.c
 *
 *  Created on: Feb 2, 2024
 *      Author: Sayed
 */
#include "STMF446RE.h"
#include "I2C_driver.h"
#include "RCC_driver.h"

#define DEVICE_ADDRESS   0x61U

void I2C_Enable(I2C_type *pI2Cx, uint8_t EnorDi){
    if(EnorDi == ENABLE){
      pI2Cx ->CR1 |= (1 << I2C_CR1_PE);
	}
	else{
		pI2Cx ->CR1 &= ~(1 << I2C_CR1_PE);
	}
}

/*********************************************************************
 * @fn      		  - I2C_CLKCNT
 *
 * @brief             - This function enables or disables peripheral clock for the given I2C
 *
 * @param[in]         - base address of the I2C peripheral
 * @param[in]         - ENABLE or DISABLE macros
 * @param[in]         -
 *
 * @return            -  none
 *
 * @Note              -  none
 */
void I2C_CLKCNT(I2C_type *pI2Cx, uint8_t EnorDi){
	if(EnorDi == ENABLE){
		if(pI2Cx == I2C1){I2C1_CLKEN();}
		else if(pI2Cx == I2C2){I2C2_CLKEN();}
		else if(pI2Cx == I2C3){I2C3_CLKEN();}
	}
	else{
		if(pI2Cx == I2C1){I2C1_CLKDI();}
		else if(pI2Cx == I2C2){I2C2_CLKDI();}
		else if(pI2Cx == I2C3){I2C3_CLKDI();}

	}
}

void I2C_Init(I2C_Handle *pI2CHandle){
	uint32_t tmp;
	/*configure the ACK control*/
	tmp = pI2CHandle->I2C_Config.I2C_ACKControl;
	pI2CHandle->pI2Cx->CR1 |= tmp << I2C_CR1_ACK;

	/*configuring the addressing mode*/
	tmp = pI2CHandle->I2C_Config.I2C_AddressMode;
	pI2CHandle->pI2Cx->OAR1 |= ((tmp << I2C_OAR1_ADD) & 0x7FU);

	/*setting bit 14 in OAR1*/
	pI2CHandle->pI2Cx->OAR1 |= (1 << 14);

			/*configure SCL Speed*/
	/*configuring the freq field in CR2 first*/
	tmp = getSystemClock() / 1000000U;
	pI2CHandle->pI2Cx->CR1 |= (tmp & 0x3FU);

	/*configuring F/S in CCR register*/
	if(pI2CHandle->I2C_Config.I2C_SCLSpeed == I2C_SCL_SM){/*if it's standered mode*/
		/*configure the mode*/
		pI2CHandle->pI2Cx->CCR &= ~(1 << I2C_CCR_F_S);

	}
	else{/*fast mode*/
		/*configure the mode*/
		pI2CHandle->pI2Cx->CCR |= (1 << I2C_CCR_F_S);
		/*configure CCR field*/
		tmp = (getSystemClock() / (2 *pI2CHandle->I2C_Config.I2C_SCLSpeed)) & 0xFFFU;
		pI2CHandle->pI2Cx->CCR |= tmp;
	}
	if(pI2CHandle ->I2C_Config.I2C_SCLSpeed == I2C_SCL_FM){ /*if it's fast mode*/
		/*configure the mode*/
		pI2CHandle->pI2Cx->CCR |= (1 << I2C_CCR_F_S);
		/*configure the duty cycle*/
		tmp = (pI2CHandle->I2C_Config.I2C_FMDutyCycle << I2C_CCR_DUTY) & 0x1;
		pI2CHandle->pI2Cx->CCR |= tmp;
		/*configure the CCR field*/
		if(pI2CHandle->I2C_Config.I2C_FMDutyCycle == I2C_FM_DUTY_2){
			tmp = (getSystemClock() / (3 *pI2CHandle->I2C_Config.I2C_SCLSpeed)) & 0xFFFU;
			pI2CHandle->pI2Cx->CCR |= tmp;
		}
		else{
			tmp = (getSystemClock() / (25 *pI2CHandle->I2C_Config.I2C_SCLSpeed)) & 0xFFFU;
			pI2CHandle->pI2Cx->CCR |= tmp;
		}
	}

	/*configure the rise time*/
	if(pI2CHandle->I2C_Config.I2C_SCLSpeed == I2C_SCL_SM){/*if it's standered mode*/
		/*rise time = (system time period / maximum allowed rise time for sm) + 1*/
		tmp = (getSystemClock() / 1000000U) + 1;
		pI2CHandle->pI2Cx->TRISE |= tmp & 0x3FU;
	}
	else{/*fast mode*/
		tmp = ((getSystemClock() * 300) / 1000000U) + 1;
		pI2CHandle->pI2Cx->TRISE |= tmp & 0x3FU;
	}
	/*configure Device Address in case it's used as slave*/
	pI2CHandle ->pI2Cx->OAR1 |= (DEVICE_ADDRESS << 1);
}


/*********************************************************************
 * @fn      		  - I2C_DeInit
 *
 * @brief             - this function stops the clock for a given I2C
 *
 * @param[in]         - base address of the I2C peripheral
 * @param[in]         -
 * @param[in]         -
 *
 * @return            -  none
 *
 * @Note              -  none

 */
void I2C_DeInit(I2C_type *pI2Cx){
	if(pI2Cx == I2C1){I2C1_CLKDI();}
	else if(pI2Cx == I2C2){I2C2_CLKDI();}
	else{I2C3_CLKDI();}
}

uint8_t I2C_GetFlagStatus(I2C_type *pI2Cx ,uint8_t FlagName){
	if(pI2Cx ->SR1 & FlagName){
		return SET;
	}
	return RESET;
}


void I2C_MasterSendData(I2C_Handle *pI2CHandle, uint8_t *pTxBuffer, uint8_t Len, uint8_t SlaveAddress){
/*generate the start condition*/
  pI2CHandle->pI2Cx->CR1 |= (1 << I2C_CR1_START);
/*wait until start bit is set in SR1*/
  while(! I2C_GetFlagStatus(pI2CHandle->pI2Cx, I2C_FLAG_SB));
/*sending the address of the slave followed by the R/nW bit*/
  SlaveAddress = SlaveAddress << 1;  /*making room for the R/nW bit*/
  SlaveAddress &= ~(1);               /*clearing LSB so it's a write condition*/
  pI2CHandle->pI2Cx->DR |= SlaveAddress;
/*wait until ADDR1 is set in SR1*/
  while(! I2C_GetFlagStatus(pI2CHandle->pI2Cx, I2C_FLAG_ADDR));
/*clearing ADDR flag*/
  uint16_t DummyRead;
  DummyRead = pI2CHandle->pI2Cx->SR1;
  DummyRead = pI2CHandle->pI2Cx->SR2;
  DummyRead++;  /*to stop combiler warning about set but not used*/
/*send the data*/
  while(Len > 0){
    /*wait until TXE is set*/
    while(! I2C_GetFlagStatus(pI2CHandle->pI2Cx, I2C_FLAG_TxE));
    pI2CHandle->pI2Cx->DR = *pTxBuffer;
    Len--;
    pTxBuffer--;
  }
/*generate stop condition*/
  /*wait for TXE and BTF to be set first*/
  while(! I2C_GetFlagStatus(pI2CHandle->pI2Cx, I2C_FLAG_TxE));
  while(! I2C_GetFlagStatus(pI2CHandle->pI2Cx, I2C_FLAG_BTF));
  /*Set the STOP bit in CR1 register*/
  pI2CHandle->pI2Cx->CR1 |= (1 << I2C_CR1_STOP);
}
void I2C_IRQInterruptConfig(uint8_t IRQNumber, uint8_t ENorDI){

}

void I2C_IRQPriorityConfig(uint8_t IRQNumber, uint32_t IRQPriority){

}
