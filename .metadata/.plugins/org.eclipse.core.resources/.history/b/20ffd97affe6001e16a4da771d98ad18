/*
 * main.c
 *
 *  Created on: Mar 14, 2024
 *      Author: Sayed
 */
#include "GPIO_driver.h"
#include "RCC_driver.h"
#include "bsp.h"
#include "string.h"
#include "Timer_Driver.h"
#include <stdio.h>

char message[] = {'H','E','L','L','O','\r','\n'};
uint32_t test = 0x1U;
uint32_t ID = 0x55U;
uint8_t size = sizeof(message);

static void CANTxconfig();
static void CANInit();

int main(void){
	GPIO_CAN1Init(GPIOA, GPIO_PIN_NO_11, 9);
	GPIO_CAN1Init(GPIOA, GPIO_PIN_NO_12, 9);
	GPIO_LEDInit();
	CANInit();
	CANTxconfig();
	//CANRxconfig();
	//enter normal mode
	CAN1 ->MCR &= ~(1 << 0);
	//wait until CAN is in normal mode
	while(CAN1 ->MSR & (1 << 0));

	//request to send
	CAN1 ->sTxMailBox[0].TIR |= (1 << 0);
	while(1){

	}
}

static void CANInit(){
	//enable the clock for the bus
	RCC ->APB1ENR |= (1 << RCC_APB1ENR_CAN1EN);
	//clear sleep bit in MCR
	CAN1 ->MCR &= ~(1U << 1);
	//initialize the CAN bus
	CAN1 ->MCR |= (1 << 0);
	//wait until CAN enters initialization mode
	while(! (CAN1 ->MSR & (1 << 0)));
	//configure the timings
	 /* pre-scaler = 1
	 * number of time quanta = 16
	 * segment 1 = 13
	 * segment 2 = 2
	 * SJW = 1
	 */
	CAN1 ->BTR &= 0x00000000U;
	CAN1 ->BTR |= (1U << 24);//SWj
	CAN1 ->BTR |= (13U << 16);//seg1
	CAN1 ->BTR |= (2U << 20);//seg2
	CAN1 ->BTR |= (2U << 0);//BRP

	//enter loop back mode
	//CAN1 ->BTR |= (1U << 30);
}

static void CANTxconfig(){
	//configure the mailbox
	CAN1 ->sTxMailBox[0].TIR &= 0x00000000U;
	CAN1 ->sTxMailBox[0].TIR |= (ID << 21);//ID
	CAN1 ->sTxMailBox[0].TIR &= ~(1U << 1);//RTR
	CAN1 ->sTxMailBox[0].TIR &= ~(1U << 2);//IDE
	CAN1 ->sTxMailBox[0].TDTR &= 0x00000000U;
	CAN1 ->sTxMailBox[0].TDTR |= (size << 0);//data size
	CAN1 ->sTxMailBox[0].TDLR &= 0x00000000U;
	CAN1 ->sTxMailBox[0].TDHR &= 0x00000000U;
	//CAN1 ->sTxMailBox[0].TDLR = test;
	for(uint32_t i = 0; i < size; i++){
		if(i < 4){
			CAN1 ->sTxMailBox[0].TDLR |= (message[i] << (i * 8)) & 0xFFU;
		}else{
			CAN1 ->sTxMailBox[0].TDHR |= (message[i] << (i * 8)) & 0xFFU;
		}
	}
}

void CAN1_RX0_IRQHandler(void){
	GPIO_ToggleOutputPin(GPIOA, GPIO_PIN_NO_5);
}
